<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Z Radio ‚Äì Live Stream</title>
  <style>
    :root { --accent:#1db954; --bg1:#0e0e0e; --bg2:#232526; }
    *{ box-sizing:border-box; margin:0; padding:0; }
    body{
      min-height:100vh; display:flex; justify-content:center; align-items:center; flex-direction:column;
      font-family:system-ui, sans-serif; background:linear-gradient(145deg,var(--bg1),var(--bg2));
      color:#f5f5f5; text-align:center; padding:1.2rem;
    }
    h1{ font-size:2.6rem; color:var(--accent); margin-bottom:.2em; }
    small{ color:#aaa; }
    #coverWrapper{
      width:220px; height:220px; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,.4);
      margin:1.3em 0 .8em; overflow:hidden;
    }
    img#cover{ width:100%; height:100%; object-fit:cover; display:block; }
    audio{ width:220px; height:40px; margin-bottom:1em; filter:drop-shadow(0 2px 4px rgba(0,0,0,.5)); }
    .meta{ font-size:1.05rem; margin-top:.3em; }
    #listeners{ font-size:.9rem; color:#ccc; margin-top:.2em; margin-bottom:.6em; display:flex; align-items:center; justify-content:center; gap:.5rem; }
    #previousTrack{ margin-top:.8em; width:220px; margin-left:auto; margin-right:auto; }
    #previousTrack .label{ font-size:.75rem; color:#888; margin-bottom:.3em; display:block; }
    #previousTrack table{ width:100%; border-collapse:collapse; }
    #previousTrack td{ padding:.3em; vertical-align:middle; }
    #previousTrack .prev-cover{ width:60px; padding-right:.5em; }
    #previousTrack .prev-cover img{ width:60px; height:60px; border-radius:4px; object-fit:cover; box-shadow:0 2px 8px rgba(0,0,0,.3); }
    #previousTrack .prev-info{ font-size:.85rem; text-align:left; }
    #previousTrack .prev-artist{ color:#aaa; font-size:.8rem; margin-bottom:.2em; }
    #previousTrack .prev-title{ color:#f5f5f5; font-weight:500; font-size:.85rem; }
    footer{ margin-top:2.5rem; font-size:.8rem; color:#888; }
    a{ color:var(--accent); }
    .song-title{ font-weight:bold; font-size:1rem; }
    .artist-name{ margin-top:.2em; color:#aaa; font-size:1rem; }
    #status{ margin-top:.6rem; font-size:.9rem; color:#ffd166; min-height:1.1em; }
    
    /* Animation des barres audio */
    .audio-bars{
      display:inline-flex; align-items:center; gap:2px; height:16px; margin-left:.3rem;
    }
    .audio-bar{
      width:3px; background:var(--accent); border-radius:2px; animation:audioWave 1.2s ease-in-out infinite;
    }
    .audio-bar:nth-child(1){ animation-delay:0s; height:8px; }
    .audio-bar:nth-child(2){ animation-delay:0.1s; height:12px; }
    .audio-bar:nth-child(3){ animation-delay:0.2s; height:16px; }
    .audio-bar:nth-child(4){ animation-delay:0.3s; height:12px; }
    .audio-bar:nth-child(5){ animation-delay:0.4s; height:8px; }
    .audio-bars.hidden{ display:none; }
    @keyframes audioWave{
      0%, 100%{ transform:scaleY(0.3); opacity:0.7; }
      50%{ transform:scaleY(1); opacity:1; }
    }
  </style>
</head>
<body>

  <h1>üéµ Z Radio</h1>
  <small>Musique 24 / 7 ‚Äì Hits & Classics</small>

  <div id="coverWrapper">
    <img id="cover" src="cover.gif" alt="Pochette de l'album">
  </div>

  <!-- Player principal -->
  <audio id="player" controls preload="none" crossorigin="anonymous">
    <source id="src" src="https://z-radio.viewdns.net/stream" type="audio/mpeg">
    <source id="src2" src="https://z-radio.viewdns.net/stream" type="audio/mp3">
    Votre navigateur ne supporte pas l'audio HTML5.
  </audio>

  <div id="title" class="meta song-title">Chargement‚Ä¶</div>
  <div id="artist" class="artist-name"></div>
  <br>
  <div id="listeners">
    Auditeurs : <span id="listenerCount">--</span>
    <span id="audioBars" class="audio-bars hidden">
      <span class="audio-bar"></span>
      <span class="audio-bar"></span>
      <span class="audio-bar"></span>
      <span class="audio-bar"></span>
      <span class="audio-bar"></span>
    </span>
  </div>
  <div id="previousTrack"></div>
  <div id="status"></div>

  <footer>
    ¬© 2025 <span style="color:var(--accent)">Z Radio</span> ‚Äì Created by <span style="color:var(--accent)">Zakaria ELORCHE</span><br/>
    Powered by <a href="#" target="_blank" rel="noopener">Icecast 2</a>
  </footer>

  <script>
    const ICECAST_BASE = "https://z-radio.viewdns.net";
    const STATUS_URLS  = [
      ICECAST_BASE + "/status-json.xsl?mount=/stream",
      ICECAST_BASE + "/status-json.xsl"
    ];
    const MOUNT        = "/stream";
    const FALLBACK_IMG = "cover.gif";

    const player   = document.getElementById("player");
    const coverEl  = document.getElementById("cover");
    const titleEl  = document.getElementById("title");
    const artistEl = document.getElementById("artist");
    const listEl   = document.getElementById("listeners");
    const statusEl = document.getElementById("status");
    const previousTrackEl = document.getElementById("previousTrack");

    let lastCoverKey = "";
    let lastSnipUpdate = 0;
    let lastTrackKey = "";
    let previousTrackData = null;
    let userPaused = false;
    let isLoading = false;
    let statusFailCount = 0;
    const STATUS_FAIL_THRESHOLD = 3;

    function normalizeText(str) {
      if (!str) return "";
      return str.replace(/^["'\s]+|["'\s]+$/g, "");
    }

    // Fonction pour normaliser et comparer les cha√Ænes (pour le matching)
    function normalizeForMatch(str) {
      if (!str) return "";
      return str.toLowerCase()
        .replace(/[^a-z0-9\s]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    // V√©rifie si un r√©sultat correspond √† notre recherche
    function matchesResult(result, artist, track) {
      if (!result) return false;
      const resultArtist = normalizeForMatch(result.artistName || result.artist || "");
      const resultTrack = normalizeForMatch(result.trackName || result.track || "");
      const searchArtist = normalizeForMatch(artist || "");
      const searchTrack = normalizeForMatch(track || "");
      
      // V√©rifie que l'artiste correspond (au moins partiellement)
      const artistMatch = !searchArtist || resultArtist.includes(searchArtist) || searchArtist.includes(resultArtist);
      // V√©rifie que le titre correspond (au moins partiellement)
      const trackMatch = !searchTrack || resultTrack.includes(searchTrack) || searchTrack.includes(resultTrack);
      
      return artistMatch && trackMatch;
    }

    // Recherche sur iTunes avec meilleure pr√©cision
    async function searchITunes(artist, track) {
      try {
        // Tentative 1 : recherche pr√©cise avec artiste et titre
        let query = "";
        if (artist && track) {
          query = `${artist} ${track}`;
        } else if (artist) {
          query = artist;
        } else if (track) {
          query = track;
        } else {
          return null;
        }

        const url = `https://itunes.apple.com/search?entity=song&limit=10&term=${encodeURIComponent(query)}`;
        const r = await fetch(url, { cache: "no-store" });
        const data = await r.json();
        
        if (data.results && data.results.length > 0) {
          // Cherche un r√©sultat qui correspond vraiment
          for (const result of data.results) {
            if (matchesResult(result, artist, track) && result.artworkUrl100) {
              return result.artworkUrl100.replace("100x100", "600x600");
            }
          }
          // Si aucun match exact, prend le premier r√©sultat
          if (data.results[0].artworkUrl100) {
            return data.results[0].artworkUrl100.replace("100x100", "600x600");
          }
        }
      } catch (err) {
        console.warn("iTunes search error:", err);
      }
      return null;
    }

    // Recherche sur Last.fm (fallback)
    async function searchLastFM(artist, track) {
      try {
        if (!artist || !track) return null;
        
        // Note: Last.fm n√©cessite une cl√© API valide. Si cette recherche √©choue,
        // le syst√®me utilisera les autres services. Obtenez une cl√© gratuite sur:
        // https://www.last.fm/api/account/create
        const apiKey = "c8d5c4d5c4d5c4d5c4d5c4d5c4d5c4d5"; // Remplacez par votre cl√© API Last.fm
        const url = `https://ws.audioscrobbler.com/2.0/?method=track.getInfo&api_key=${apiKey}&artist=${encodeURIComponent(artist)}&track=${encodeURIComponent(track)}&format=json`;
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) return null;
        const data = await r.json();
        
        if (data.track && data.track.album && data.track.album.image) {
          // Last.fm fournit plusieurs tailles, on prend la grande (extralarge ou large)
          const images = data.track.album.image;
          for (let i = images.length - 1; i >= 0; i--) {
            if (images[i]["#text"]) {
              return images[i]["#text"];
            }
          }
        }
      } catch (err) {
        console.warn("Last.fm search error:", err);
      }
      return null;
    }

    // Recherche sur MusicBrainz + Cover Art Archive (gratuit, open source)
    async function searchMusicBrainz(artist, track) {
      try {
        if (!artist || !track) return null;
        
        // √âtape 1 : Rechercher l'enregistrement (recording) sur MusicBrainz
        const searchUrl = `https://musicbrainz.org/ws/2/recording/?query=artist:"${encodeURIComponent(artist)}" AND recording:"${encodeURIComponent(track)}"&fmt=json&limit=1`;
        const searchRes = await fetch(searchUrl, { 
          cache: "no-store",
          headers: {
            'User-Agent': 'ZRadio/1.0 (https://z-radio.viewdns.net)',
            'Accept': 'application/json'
          }
        });
        
        if (!searchRes.ok) return null;
        const searchData = await searchRes.json();
        
        if (!searchData.recordings || searchData.recordings.length === 0) return null;
        
        // √âtape 2 : R√©cup√©rer les releases (albums) de cet enregistrement
        const recordingId = searchData.recordings[0].id;
        const releaseUrl = `https://musicbrainz.org/ws/2/recording/${recordingId}?inc=releases&fmt=json`;
        const releaseRes = await fetch(releaseUrl, {
          cache: "no-store",
          headers: {
            'User-Agent': 'ZRadio/1.0 (https://z-radio.viewdns.net)',
            'Accept': 'application/json'
          }
        });
        
        if (!releaseRes.ok) return null;
        const releaseData = await releaseRes.json();
        
        if (!releaseData.releases || releaseData.releases.length === 0) return null;
        
        // √âtape 3 : R√©cup√©rer la cover depuis Cover Art Archive
        const releaseId = releaseData.releases[0].id;
        const coverUrl = `https://coverartarchive.org/release/${releaseId}/front-500`;
        
        // V√©rifier que l'image existe
        const coverCheck = await fetch(coverUrl, { method: 'HEAD', cache: "no-store" });
        if (coverCheck.ok) {
          return coverUrl;
        }
      } catch (err) {
        console.warn("MusicBrainz search error:", err);
      }
      return null;
    }

    // Recherche sur Deezer (API gratuite, pas besoin de cl√© pour la recherche)
    async function searchDeezer(artist, track) {
      try {
        if (!artist || !track) return null;
        
        const query = `${artist} ${track}`;
        const url = `https://api.deezer.com/search?q=${encodeURIComponent(query)}&limit=5`;
        const r = await fetch(url, { cache: "no-store" });
        
        if (!r.ok) return null;
        const data = await r.json();
        
        if (data.data && data.data.length > 0) {
          // Cherche un r√©sultat qui correspond
          for (const result of data.data) {
            if (matchesResult({ 
              artist: result.artist?.name, 
              track: result.title 
            }, artist, track) && result.album?.cover_xl) {
              return result.album.cover_xl; // XL = 1000x1000px
            }
          }
          // Si aucun match exact, prend le premier r√©sultat
          if (data.data[0]?.album?.cover_xl) {
            return data.data[0].album.cover_xl;
          }
        }
      } catch (err) {
        console.warn("Deezer search error:", err);
      }
      return null;
    }

    async function ensureCover(explicitCover, track, artist) {
      const key = [explicitCover || "", track || "", artist || ""].join("|");
      if (key === lastCoverKey) return;
      lastCoverKey = key;

      if (explicitCover) {
        const bust = explicitCover.includes("?") ? "&" : "?";
        coverEl.src = explicitCover + bust + "t=" + Date.now();
        return;
      }

      if (!track && !artist) {
        coverEl.src = FALLBACK_IMG;
        return;
      }

      // Recherche en cascade sur plusieurs services (du plus fiable au moins fiable)
      // Tentative 1 : iTunes (meilleure qualit√©, 600x600px)
      let coverUrl = await searchITunes(artist, track);
      
      // Tentative 2 : Deezer (tr√®s bonne qualit√©, 1000x1000px, API gratuite)
      if (!coverUrl) {
        coverUrl = await searchDeezer(artist, track);
      }
      
      // Tentative 3 : MusicBrainz + Cover Art Archive (gratuit, open source, 500x500px)
      if (!coverUrl) {
        coverUrl = await searchMusicBrainz(artist, track);
      }
      
      // Tentative 4 : Last.fm (si cl√© API configur√©e)
      if (!coverUrl) {
        coverUrl = await searchLastFM(artist, track);
      }

      if (coverUrl) {
        coverEl.src = coverUrl;
      } else {
        coverEl.src = FALLBACK_IMG;
      }
    }

    async function updatePreviousTrackDisplay() {
      if (!previousTrackEl) return;
      
      if (previousTrackData && previousTrackData.track) {
        let coverUrl = previousTrackData.cover || FALLBACK_IMG;
        
        if (!previousTrackData.cover && previousTrackData.artist && previousTrackData.track) {
          // Utilise la m√™me logique en cascade que ensureCover
          let foundCover = await searchITunes(previousTrackData.artist, previousTrackData.track);
          if (!foundCover) foundCover = await searchDeezer(previousTrackData.artist, previousTrackData.track);
          if (!foundCover) foundCover = await searchMusicBrainz(previousTrackData.artist, previousTrackData.track);
          if (!foundCover) foundCover = await searchLastFM(previousTrackData.artist, previousTrackData.track);
          if (foundCover) {
            coverUrl = foundCover;
          }
        }
        
        const artist = previousTrackData.artist || "";
        const track = previousTrackData.track || "";
        
        previousTrackEl.innerHTML = `
          <span class="label">Pr√©c√©dent :</span>
          <table>
            <tr>
              <td class="prev-cover">
                <img src="${coverUrl}" alt="Cover pr√©c√©dent" onerror="this.src='${FALLBACK_IMG}'">
              </td>
              <td class="prev-info">
                <div class="prev-artist">${artist || "Artiste inconnu"}</div>
                <div class="prev-title">${track}</div>
              </td>
            </tr>
          </table>
        `;
      } else {
        previousTrackEl.textContent = "";
      }
    }

    async function refreshPreviousTrack() {
      if (window.location.protocol === "file:") return;
      
      const historyFiles = [
        "Snip_History.json",
        "Snip_PlayHistory.json",
        "history.json",
        "playhistory.json",
        "Snip_Metadata.json"
      ];

      for (const file of historyFiles) {
        try {
          const r = await fetch(file, { cache: "no-store" });
          if (!r.ok) continue;
          const data = await r.json();

          let history = null;
          
          if (Array.isArray(data)) {
            history = data;
          } else if (data.history && Array.isArray(data.history)) {
            history = data.history;
          } else if (data.previous) {
            history = [data.previous];
          } else if (data.last && data.last.track) {
            history = [data.last];
          } else if (data.previousTrack || data.previousTitle) {
            const prevTrack = normalizeText(data.previousTrack || data.previousTitle || "");
            const prevArtist = normalizeText(data.previousArtist || data.previousArtistName || "");
            if (prevTrack || prevArtist) {
              previousTrackData = { 
                track: prevTrack, 
                artist: prevArtist,
                cover: data.previousCover || data.previousAlbumArt || null
              };
              updatePreviousTrackDisplay();
              return;
            }
          } else if (data.tracks && Array.isArray(data.tracks)) {
            history = data.tracks;
          }

          if (history && history.length > 0) {
            const currentTrack = titleEl.textContent;
            const currentArtist = artistEl.textContent;
            
            let previous = null;
            for (let i = history.length - 1; i >= 0; i--) {
              const entry = history[i];
              const entryTrack = normalizeText(entry.track || entry.title || entry.name || "");
              const entryArtist = normalizeText(entry.artist || entry.artistName || entry.artist_name || "");
              
              if (entryTrack && entryArtist) {
                if (entryTrack !== currentTrack || entryArtist !== currentArtist) {
                  previous = { 
                    track: entryTrack, 
                    artist: entryArtist,
                    cover: entry.cover || entry.albumArt || entry.artwork || null
                  };
                  break;
                }
              } else if (entryTrack && !currentTrack) {
                previous = { 
                  track: entryTrack, 
                  artist: entryArtist || "",
                  cover: entry.cover || entry.albumArt || entry.artwork || null
                };
                break;
              }
            }

            if (previous) {
              previousTrackData = previous;
              updatePreviousTrackDisplay();
            }
            return;
          }
        } catch (e) {
          console.debug("Erreur lecture historique:", file, e);
        }
      }
      
      updatePreviousTrackDisplay();
    }

    async function refreshSnip() {
      if (window.location.protocol === "file:") return;
      try {
        const r = await fetch("Snip_Metadata.json", { cache: "no-store" });
        if (!r.ok) return;
        const meta = await r.json();

        const track  = meta.track  ? normalizeText(meta.track)  : "";
        const artist = meta.artist ? normalizeText(meta.artist) : "";
        const currentKey = track + "|" + artist;

        if (currentKey !== lastTrackKey && lastTrackKey) {
          const oldTrack = titleEl.textContent;
          const oldArtist = artistEl.textContent;
          const oldCover = coverEl.src;
          if (oldTrack && oldTrack !== "Chargement‚Ä¶") {
            previousTrackData = { 
              track: oldTrack, 
              artist: oldArtist,
              cover: oldCover !== FALLBACK_IMG ? oldCover : null
            };
            updatePreviousTrackDisplay();
          }
        }

        if (currentKey !== lastTrackKey) {
          lastCoverKey = "";
          lastTrackKey = currentKey;
          refreshPreviousTrack();
        }

        if (track)  titleEl.textContent  = track;
        if (artist) artistEl.textContent = artist;

        await ensureCover(meta.cover, track, artist);
        lastSnipUpdate = Date.now();

      } catch (e) { }
    }

    if (window.location.protocol !== "file:") {
      refreshSnip();
      refreshPreviousTrack();
      setInterval(refreshSnip, 2000);
      setInterval(refreshPreviousTrack, 3000);
      updatePreviousTrackDisplay();
    }

    function pickSource(icestats) {
      let s = icestats?.source;
      if (!s) return null;
      if (Array.isArray(s)) {
        return (
          s.find(o => (o.listenurl || "").endsWith(MOUNT)) ||
          s.find(o => (o.listeners || 0) > 0) ||
          s[0]
        );
      }
      return s;
    }

    async function refreshIcecast() {
      let lastError = null;
      for (const baseUrl of STATUS_URLS) {
        try {
          const url = baseUrl + (baseUrl.includes("?") ? "&" : "?") + "t=" + Date.now();
          const r = await fetch(url, { cache:"no-store", mode:"cors" });
          if (!r.ok) throw new Error("HTTP " + r.status);
          const data = await r.json();

          const src = pickSource(data.icestats);
          if (!src) throw new Error("Aucune source");

          const listenerCount = src.listeners ?? 0;
          const countSpan = document.getElementById("listenerCount");
          if (countSpan) countSpan.textContent = listenerCount;

          statusEl.textContent = "";
          statusFailCount = 0;

          const snipFresh = Date.now() - lastSnipUpdate < 7000;
          const hasTitle = titleEl.textContent && titleEl.textContent !== "Chargement‚Ä¶";
          const hasArtist = artistEl.textContent && artistEl.textContent.length > 0;

          const iceTitle = src.title || src.server_name || "";
          if (iceTitle) {
            const [artistPart, ...titleParts] = iceTitle.split(" - ");
            const iceArtist = titleParts.length ? normalizeText(artistPart) : "";
            const iceTrack = titleParts.length ? normalizeText(titleParts.join(" - ")) : normalizeText(iceTitle);
            const iceKey = iceTrack + "|" + iceArtist;

            if (!snipFresh || !hasTitle || !hasArtist || iceKey !== lastTrackKey) {
              if (iceKey !== lastTrackKey && lastTrackKey) {
                const oldTrack = titleEl.textContent;
                const oldArtist = artistEl.textContent;
                const oldCover = coverEl.src;
                if (oldTrack && oldTrack !== "Chargement‚Ä¶") {
                  previousTrackData = { 
                    track: oldTrack, 
                    artist: oldArtist,
                    cover: oldCover !== FALLBACK_IMG ? oldCover : null
                  };
                  updatePreviousTrackDisplay();
                }
              }

              if ((!snipFresh || !hasArtist) && iceArtist) {
                artistEl.textContent = iceArtist;
              }
              if ((!snipFresh || !hasTitle) && iceTrack) {
                titleEl.textContent = iceTrack;
              }
              
              if (iceKey !== lastTrackKey) {
                lastCoverKey = "";
                lastTrackKey = iceKey;
                refreshPreviousTrack();
              }
              
              await ensureCover(null, titleEl.textContent, artistEl.textContent);
              if (!snipFresh) lastSnipUpdate = 0;
            }
          }

          return;
        } catch (e) {
          lastError = e;
        }
      }

      console.error(lastError);
      statusFailCount++;
      const playerLooksOk = !player.paused && player.readyState >= 2;
      if (!playerLooksOk && statusFailCount >= STATUS_FAIL_THRESHOLD) {
        statusEl.textContent = "Flux indisponible‚Ä¶";
        coverEl.src = FALLBACK_IMG;
      }
    }

    refreshIcecast();
    setInterval(refreshIcecast, 15000);

    // ---- Gestion du bouton Play/Pause (sans intro, sans reconnexion automatique)
    player.addEventListener("play", () => {
      userPaused = false;
      const audioBars = document.getElementById("audioBars");
      if (audioBars) audioBars.classList.remove("hidden");
    });

    player.addEventListener("pause", () => {
      userPaused = true;
      const audioBars = document.getElementById("audioBars");
      if (audioBars) audioBars.classList.add("hidden");
    });

    player.addEventListener("playing", () => {
      const audioBars = document.getElementById("audioBars");
      if (audioBars) audioBars.classList.remove("hidden");
    });
    
    // Gestion des erreurs du lecteur
    player.addEventListener("error", (e) => {
      const error = player.error;
      let errorMsg = "Erreur de lecture";
      if (error) {
        switch (error.code) {
          case error.MEDIA_ERR_ABORTED:
            errorMsg = "Lecture interrompue";
            break;
          case error.MEDIA_ERR_NETWORK:
            errorMsg = "Erreur r√©seau - Impossible de se connecter au flux";
            break;
          case error.MEDIA_ERR_DECODE:
            errorMsg = "Erreur de d√©codage";
            break;
          case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
            errorMsg = "Format non support√©";
            break;
          default:
            errorMsg = `Erreur inconnue (code: ${error.code})`;
        }
        
        console.error("Erreur lecteur audio:", {
          code: error.code,
          message: errorMsg,
          networkState: player.networkState,
          readyState: player.readyState,
          src: player.src
        });
      } else {
        console.error("Erreur lecteur (sans d√©tails):", e);
      }
      
      statusEl.textContent = errorMsg;
    });
  </script>
</body>
</html>
