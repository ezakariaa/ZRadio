<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Z Radio â€“ Live Stream</title>
  <link rel="preload" href="cover.gif" as="image">
  <style>
    :root { --accent:#1db954; --bg1:#0e0e0e; --bg2:#232526; }
    *{ box-sizing:border-box; margin:0; padding:0; }
    body{
      min-height:100vh; display:flex; justify-content:center; align-items:center; flex-direction:column;
      font-family:system-ui, sans-serif; background:linear-gradient(145deg,var(--bg1),var(--bg2));
      color:#f5f5f5; text-align:center; padding:1.2rem;
    }
    h1{ font-size:2.6rem; color:var(--accent); margin-bottom:.2em; }
    small{ color:#aaa; }
    #coverWrapper{
      width:220px; height:220px; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,.4);
      margin:1.3em 0 .8em; overflow:hidden;
    }
    img#cover{ width:100%; height:100%; object-fit:cover; display:block; }
    audio{ width:220px; height:40px; margin-bottom:1em; filter:drop-shadow(0 2px 4px rgba(0,0,0,.5)); }
    .meta{ font-size:1.05rem; margin-top:.3em; }
    #listeners{ font-size:.9rem; color:#ccc; margin-top:.2em; margin-bottom:.6em; display:flex; align-items:center; justify-content:center; gap:.5rem; }
    #previousTrack{ margin-top:.8em; width:220px; margin-left:auto; margin-right:auto; }
    #previousTrack .label{ font-size:.75rem; color:#888; margin-bottom:.3em; display:block; }
    #previousTrack table{ width:100%; border-collapse:collapse; }
    #previousTrack td{ padding:.3em; vertical-align:middle; }
    #previousTrack .prev-cover{ width:60px; padding-right:.5em; }
    #previousTrack .prev-cover img{ width:60px; height:60px; border-radius:4px; object-fit:cover; box-shadow:0 2px 8px rgba(0,0,0,.3); }
    #previousTrack .prev-info{ font-size:.85rem; text-align:left; }
    #previousTrack .prev-artist{ color:#aaa; font-size:.8rem; margin-bottom:.2em; }
    #previousTrack .prev-title{ color:#f5f5f5; font-weight:500; font-size:.85rem; }
    footer{ margin-top:2.5rem; font-size:.8rem; color:#888; }
    a{ color:var(--accent); }
    .song-title{ font-weight:bold; font-size:1rem; }
    .artist-name{ margin-top:.2em; color:#aaa; font-size:1rem; }
    #status{ margin-top:.6rem; font-size:.9rem; color:#ffd166; min-height:1.1em; cursor:pointer; text-decoration:underline; text-underline-offset:2px; }
    #status:empty{ cursor:default; text-decoration:none; }
    
    /* Animation des barres audio */
    .audio-bars{
      display:inline-flex; align-items:center; gap:2px; height:16px; margin-left:.3rem;
    }
    .audio-bar{
      width:3px; background:var(--accent); border-radius:2px; animation:audioWave 1.2s ease-in-out infinite;
    }
    .audio-bar:nth-child(1){ animation-delay:0s; height:8px; }
    .audio-bar:nth-child(2){ animation-delay:0.1s; height:12px; }
    .audio-bar:nth-child(3){ animation-delay:0.2s; height:16px; }
    .audio-bar:nth-child(4){ animation-delay:0.3s; height:12px; }
    .audio-bar:nth-child(5){ animation-delay:0.4s; height:8px; }
    .audio-bars.hidden{ display:none; }
    @keyframes audioWave{
      0%, 100%{ transform:scaleY(0.3); opacity:0.7; }
      50%{ transform:scaleY(1); opacity:1; }
    }
  </style>
</head>
<body>

  <h1>ðŸŽµ Z Radio</h1>
  <small>Musique 24 / 7 â€“ Hits & Classics</small>

  <div id="coverWrapper">
    <img id="cover" src="cover.gif" alt="Pochette de l'album">
  </div>

  <!-- Player principal -->
  <audio id="player" controls preload="metadata" crossorigin="anonymous">
    <source id="src" src="https://z-radio.viewdns.net/stream" type="audio/mpeg">
    <source id="src2" src="https://z-radio.viewdns.net/stream" type="audio/mp3">
    <source id="src3" src="https://z-radio.viewdns.net/stream" type="audio/x-mpeg">
    <source id="src4" src="https://z-radio.viewdns.net/stream" type="audio/mp4">
    <source id="src5" src="https://z-radio.viewdns.net/stream" type="audio/aac">
    <source id="src6" src="https://z-radio.viewdns.net/stream" type="audio/ogg">
    <source id="src7" src="https://z-radio.viewdns.net/stream">
    Votre navigateur ne supporte pas l'audio HTML5.
  </audio>

  <div id="title" class="meta song-title">Z Radio</div>
  <div id="artist" class="artist-name">Live Stream</div>
  <!-- Protection : ne jamais rÃ©initialiser Ã  "Chargementâ€¦" une fois qu'on a un titre -->
  <br>
  <div id="listeners">
    Auditeurs : <span id="listenerCount">--</span>
    <span id="audioBars" class="audio-bars hidden">
      <span class="audio-bar"></span>
      <span class="audio-bar"></span>
      <span class="audio-bar"></span>
      <span class="audio-bar"></span>
      <span class="audio-bar"></span>
    </span>
  </div>
  <div id="previousTrack"></div>
  <div id="status"></div>

  <footer>
    Â© 2025 <span style="color:var(--accent)">Z Radio</span> â€“ Created by <span style="color:var(--accent)">Zakaria ELORCHE</span><br/>
    Powered by <a href="#" target="_blank" rel="noopener">Icecast 2</a>
  </footer>

  <script>
    const ICECAST_BASE = "https://z-radio.viewdns.net";
    const STATUS_URLS  = [
      ICECAST_BASE + "/status-json.xsl?mount=/stream",
      ICECAST_BASE + "/status-json.xsl"
    ];
    const MOUNT        = "/stream";
    const STREAM_URL   = ICECAST_BASE + "/stream"; // URL du stream (constante pour Ã©viter la corruption)
    const FALLBACK_IMG = "cover.gif";

    const player   = document.getElementById("player");
    const coverEl  = document.getElementById("cover");
    const titleEl  = document.getElementById("title");
    const artistEl = document.getElementById("artist");
    const listEl   = document.getElementById("listeners");
    const statusEl = document.getElementById("status");
    const previousTrackEl = document.getElementById("previousTrack");

    let lastCoverKey = "";
    let lastSnipUpdate = 0;
    let lastTrackKey = "";
    let previousTrackData = null;
    let userPaused = false;
    let wasPaused = false; // Flag pour dÃ©tecter si l'utilisateur a mis en pause
    let isLoading = false;
    let statusFailCount = 0;
    const STATUS_FAIL_THRESHOLD = 3;
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    const MAX_RECONNECT_ATTEMPTS = 10; // AugmentÃ© pour plus de rÃ©silience
    const RECONNECT_DELAY = 2000; // 2 secondes (plus rapide)
    let lastKnownTitle = "";
    let lastKnownArtist = "";
    const FETCH_TIMEOUT = 8000; // 8 secondes pour les rÃ©seaux lents (Ã©viter timeout intermittent)
    let isInitialLoad = true;
    let bufferingTimer = null;
    const BUFFERING_TIMEOUT = 8000; // 8 secondes avant reconnexion si buffering bloquÃ©
    let healthCheckTimer = null;
    let lastPlayTime = 0;
    const HEALTH_CHECK_INTERVAL = 15000; // VÃ©rifier toutes les 15 secondes
    const MAX_STALL_TIME = 20000; // Si pas de progression pendant 20 secondes, reconnecter

    function normalizeText(str) {
      if (!str) return "";
      return str.replace(/^["'\s]+|["'\s]+$/g, "");
    }

    // Fonction fetch avec timeout pour Ã©viter les blocages
    async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      try {
        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
          throw new Error('Timeout: requÃªte trop longue');
        }
        throw error;
      }
    }

    // Fonction pour dÃ©tecter le Content-Type rÃ©el du flux
    async function testStreamContentType() {
      try {
        const response = await fetchWithTimeout(ICECAST_BASE + "/stream", {
          method: "HEAD",
          cache: "no-store"
        }, 3000);
        
        const contentType = response.headers.get("Content-Type");
        console.log("Content-Type du flux:", contentType);
        return contentType;
      } catch (error) {
        console.error("Erreur lors de la dÃ©tection du Content-Type:", error);
        return null;
      }
    }

    // Fonction pour mettre Ã  jour le titre en prÃ©servant les valeurs existantes
    function safeUpdateTitle(newTitle) {
      if (newTitle && newTitle.trim()) {
        titleEl.textContent = newTitle;
        lastKnownTitle = newTitle;
        return true;
      }
      // Si pas de nouveau titre mais qu'on en a un connu, le garder
      if (!newTitle && lastKnownTitle) {
        titleEl.textContent = lastKnownTitle;
        return false;
      }
      // Ne jamais rÃ©initialiser Ã  "Chargementâ€¦" si on a dÃ©jÃ  un titre
      if (!newTitle && titleEl.textContent && titleEl.textContent !== "Chargementâ€¦") {
        return false; // Garder le titre actuel
      }
      return false;
    }

    // Fonction pour mettre Ã  jour l'artiste en prÃ©servant les valeurs existantes
    function safeUpdateArtist(newArtist) {
      if (newArtist && newArtist.trim()) {
        artistEl.textContent = newArtist;
        lastKnownArtist = newArtist;
        return true;
      }
      // Si pas de nouvel artiste mais qu'on en a un connu, le garder
      if (!newArtist && lastKnownArtist) {
        artistEl.textContent = lastKnownArtist;
        return false;
      }
      return false;
    }

    // Fonction pour normaliser et comparer les chaÃ®nes (pour le matching)
    function normalizeForMatch(str) {
      if (!str) return "";
      return str.toLowerCase()
        .replace(/[^a-z0-9\s]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    // VÃ©rifie si un rÃ©sultat correspond Ã  notre recherche
    function matchesResult(result, artist, track) {
      if (!result) return false;
      const resultArtist = normalizeForMatch(result.artistName || result.artist || "");
      const resultTrack = normalizeForMatch(result.trackName || result.track || "");
      const searchArtist = normalizeForMatch(artist || "");
      const searchTrack = normalizeForMatch(track || "");
      
      // VÃ©rifie que l'artiste correspond (au moins partiellement)
      const artistMatch = !searchArtist || resultArtist.includes(searchArtist) || searchArtist.includes(resultArtist);
      // VÃ©rifie que le titre correspond (au moins partiellement)
      const trackMatch = !searchTrack || resultTrack.includes(searchTrack) || searchTrack.includes(resultTrack);
      
      return artistMatch && trackMatch;
    }

    // Recherche sur iTunes avec meilleure prÃ©cision
    async function searchITunes(artist, track) {
      try {
        // Accepter artiste seul ou titre seul
        if (!artist && !track) return null;
        
        let query = "";
        if (artist && track) {
          query = `${artist} ${track}`;
        } else if (artist) {
          query = artist;
        } else if (track) {
          query = track;
        }

        const url = `https://itunes.apple.com/search?entity=song&limit=20&term=${encodeURIComponent(query)}`;
        const r = await fetchWithTimeout(url, { cache: "no-store" }, 2000);
        if (!r.ok) return null;
        const data = await r.json();
        
        if (data.results && data.results.length > 0) {
          // Si on a artiste ET titre, chercher un match exact
          if (artist && track) {
            for (const result of data.results) {
              if (matchesResult(result, artist, track) && result.artworkUrl100) {
                return result.artworkUrl100.replace("100x100", "600x600");
              }
            }
          }
          // Sinon, prendre le premier rÃ©sultat avec artwork
          for (const result of data.results) {
            if (result.artworkUrl100) {
              return result.artworkUrl100.replace("100x100", "600x600");
            }
          }
        }
      } catch (err) {
        console.warn("iTunes search error:", err);
      }
      return null;
    }

    // Recherche sur Last.fm (fallback)
    async function searchLastFM(artist, track) {
      try {
        if (!artist || !track) return null;
        
        // Note: Last.fm nÃ©cessite une clÃ© API valide. Si cette recherche Ã©choue,
        // le systÃ¨me utilisera les autres services. Obtenez une clÃ© gratuite sur:
        // https://www.last.fm/api/account/create
        const apiKey = "c8d5c4d5c4d5c4d5c4d5c4d5c4d5c4d5"; // Remplacez par votre clÃ© API Last.fm
        
        // MÃ©thode 1 : track.getInfo (plus prÃ©cis)
        try {
          const url = `https://ws.audioscrobbler.com/2.0/?method=track.getInfo&api_key=${apiKey}&artist=${encodeURIComponent(artist)}&track=${encodeURIComponent(track)}&format=json`;
          const r = await fetchWithTimeout(url, { cache: "no-store" }, 2000);
          if (r.ok) {
            const data = await r.json();
            if (data.track && data.track.album && data.track.album.image) {
              // Last.fm fournit plusieurs tailles, on prend la grande (extralarge ou large)
              const images = data.track.album.image;
              for (let i = images.length - 1; i >= 0; i--) {
                if (images[i]["#text"]) {
                  return images[i]["#text"];
                }
              }
            }
          }
        } catch (e) {
          // Si track.getInfo Ã©choue, essayer album.search
        }
        
        // MÃ©thode 2 : album.search (si track.getInfo Ã©choue)
        try {
          const searchUrl = `https://ws.audioscrobbler.com/2.0/?method=album.search&api_key=${apiKey}&album=${encodeURIComponent(track)}&artist=${encodeURIComponent(artist)}&format=json`;
          const r = await fetchWithTimeout(searchUrl, { cache: "no-store" }, 2000);
          if (r.ok) {
            const data = await r.json();
            if (data.results && data.results.albummatches && data.results.albummatches.album) {
              const albums = Array.isArray(data.results.albummatches.album) 
                ? data.results.albummatches.album 
                : [data.results.albummatches.album];
              for (const album of albums) {
                if (album.image && album.image.length > 0) {
                  // Prendre la plus grande image
                  for (let i = album.image.length - 1; i >= 0; i--) {
                    if (album.image[i]["#text"]) {
                      return album.image[i]["#text"];
                    }
                  }
                }
              }
            }
          }
        } catch (e) {
          // Si les deux mÃ©thodes Ã©chouent, retourner null
        }
      } catch (err) {
        console.warn("Last.fm search error:", err);
      }
      return null;
    }

    // Recherche sur MusicBrainz + Cover Art Archive (gratuit, open source)
    async function searchMusicBrainz(artist, track) {
      try {
        if (!artist || !track) return null;
        
        // Ã‰tape 1 : Rechercher l'enregistrement (recording) sur MusicBrainz
        const searchUrl = `https://musicbrainz.org/ws/2/recording/?query=artist:"${encodeURIComponent(artist)}" AND recording:"${encodeURIComponent(track)}"&fmt=json&limit=1`;
        const searchRes = await fetchWithTimeout(searchUrl, { 
          cache: "no-store",
          headers: {
            'User-Agent': 'ZRadio/1.0 (https://z-radio.viewdns.net)',
            'Accept': 'application/json'
          }
        }, 2000); // 2s max pour MusicBrainz
        
        if (!searchRes.ok) return null;
        const searchData = await searchRes.json();
        
        if (!searchData.recordings || searchData.recordings.length === 0) return null;
        
        // Ã‰tape 2 : RÃ©cupÃ©rer les releases (albums) de cet enregistrement
        const recordingId = searchData.recordings[0].id;
        const releaseUrl = `https://musicbrainz.org/ws/2/recording/${recordingId}?inc=releases&fmt=json`;
        const releaseRes = await fetchWithTimeout(releaseUrl, {
          cache: "no-store",
          headers: {
            'User-Agent': 'ZRadio/1.0 (https://z-radio.viewdns.net)',
            'Accept': 'application/json'
          }
        }, 2000);
        
        if (!releaseRes.ok) return null;
        const releaseData = await releaseRes.json();
        
        if (!releaseData.releases || releaseData.releases.length === 0) return null;
        
        // Ã‰tape 3 : RÃ©cupÃ©rer la cover depuis Cover Art Archive
        const releaseId = releaseData.releases[0].id;
        const coverUrl = `https://coverartarchive.org/release/${releaseId}/front-500`;
        
        // VÃ©rifier que l'image existe
        const coverCheck = await fetchWithTimeout(coverUrl, { method: 'HEAD', cache: "no-store" }, 2000);
        if (coverCheck.ok) {
          return coverUrl;
        }
      } catch (err) {
        console.warn("MusicBrainz search error:", err);
      }
      return null;
    }

    // Recherche sur Deezer (API gratuite, pas besoin de clÃ© pour la recherche)
    async function searchDeezer(artist, track) {
      try {
        // Accepter artiste seul ou titre seul
        if (!artist && !track) return null;
        
        const query = artist && track ? `${artist} ${track}` : (artist || track);
        const url = `https://api.deezer.com/search?q=${encodeURIComponent(query)}&limit=10`;
        const r = await fetchWithTimeout(url, { cache: "no-store" }, 2000);
        
        if (!r.ok) return null;
        const data = await r.json();
        
        if (data.data && data.data.length > 0) {
          // Si on a artiste ET titre, chercher un match exact
          if (artist && track) {
            for (const result of data.data) {
              if (matchesResult({ 
                artist: result.artist?.name, 
                track: result.title 
              }, artist, track) && result.album?.cover_xl) {
                return result.album.cover_xl;
              }
            }
          }
          // Sinon, prendre le premier rÃ©sultat avec cover
          for (const result of data.data) {
            if (result.album?.cover_xl) {
              return result.album.cover_xl; // XL = 1000x1000px
            }
          }
        }
      } catch (err) {
        console.warn("Deezer search error:", err);
      }
      return null;
    }

    // Recherche sur Spotify (via mÃ©thode alternative - l'API officielle nÃ©cessite OAuth)
    async function searchSpotify(artist, track) {
      try {
        if (!artist || !track) return null;
        
        // L'API Spotify officielle nÃ©cessite OAuth, mais on peut utiliser des services tiers
        // Alternative : utiliser unembed.com ou d'autres services qui fournissent les mÃ©tadonnÃ©es Spotify
        const query = `${artist} ${track}`;
        
        // MÃ©thode 1 : Essayer via unembed (service tiers qui permet d'obtenir les mÃ©tadonnÃ©es Spotify)
        try {
          const unembedUrl = `https://unembed.com/api/spotify/search?q=${encodeURIComponent(query)}`;
          const r = await fetchWithTimeout(unembedUrl, { cache: "no-store" }, 2000);
          if (r.ok) {
            const data = await r.json();
            if (data && data.album && data.album.images && data.album.images.length > 0) {
              return data.album.images[0].url;
            }
          }
        } catch (e) {
          // Si unembed Ã©choue, essayer une autre mÃ©thode
        }
        
        // MÃ©thode 2 : Utiliser l'API Spotify Web (peut fonctionner sans token pour certaines requÃªtes)
        // Note: Cette mÃ©thode peut ne pas fonctionner Ã  cause des restrictions CORS
        // On la laisse en commentaire car elle nÃ©cessite gÃ©nÃ©ralement une authentification
        
      } catch (err) {
        console.warn("Spotify search error:", err);
      }
      return null;
    }

    // Recherche sur Discogs (API gratuite, peut fonctionner sans clÃ© avec limites)
    async function searchDiscogs(artist, track) {
      try {
        if (!artist || !track) return null;
        
        const query = `${artist} ${track}`;
        // Discogs API peut fonctionner sans clÃ© mais avec des limites de rate
        const url = `https://api.discogs.com/database/search?q=${encodeURIComponent(query)}&type=release&per_page=5`;
        const r = await fetchWithTimeout(url, { 
          cache: "no-store",
          headers: {
            'User-Agent': 'ZRadio/1.0 (https://z-radio.viewdns.net)',
            'Accept': 'application/json'
          }
        }, 2000);
        
        if (r.ok) {
          const data = await r.json();
          if (data.results && data.results.length > 0) {
            // Chercher un rÃ©sultat qui correspond
            for (const result of data.results) {
              if (result.thumb) {
                const resultTitle = result.title || "";
                const resultArtist = result.artist || "";
                // VÃ©rifier si Ã§a correspond
                if (matchesResult({
                  artist: resultArtist,
                  track: resultTitle
                }, artist, track)) {
                  // Discogs fournit des thumbnails, essayer d'obtenir une image plus grande
                  // Les URLs Discogs peuvent Ãªtre modifiÃ©es pour obtenir des tailles diffÃ©rentes
                  if (result.thumb.includes('150x150')) {
                    return result.thumb.replace('150x150', '500x500');
                  }
                  return result.thumb;
                }
              }
            }
            // Prendre le premier rÃ©sultat avec thumb
            const firstResult = data.results.find(r => r.thumb);
            if (firstResult?.thumb) {
              if (firstResult.thumb.includes('150x150')) {
                return firstResult.thumb.replace('150x150', '500x500');
              }
              return firstResult.thumb;
            }
          }
        }
      } catch (err) {
        console.warn("Discogs search error:", err);
      }
      return null;
    }

    // Recherche sur Amazon Music (difficile sans API officielle)
    async function searchAmazonMusic(artist, track) {
      try {
        if (!artist || !track) return null;
        
        // Amazon Music n'a pas d'API publique accessible facilement
        // Le scraping direct ne fonctionne pas Ã  cause de CORS et de la protection anti-bot
        // On peut essayer via des services tiers, mais pour l'instant on retourne null
        // Note: Si vous avez accÃ¨s Ã  l'API Amazon Music, vous pouvez l'implÃ©menter ici
        
        return null;
      } catch (err) {
        console.debug("Amazon Music search (non disponible):", err);
      }
      return null;
    }

    // Recherche sur Genius (API nÃ©cessite une clÃ©, mais on peut essayer)
    async function searchGenius(artist, track) {
      try {
        if (!artist || !track) return null;
        
        // Genius API nÃ©cessite gÃ©nÃ©ralement une clÃ©, mais certaines requÃªtes peuvent fonctionner
        const query = `${artist} ${track}`;
        const url = `https://api.genius.com/search?q=${encodeURIComponent(query)}`;
        
        // Essayer sans clÃ© (peut ne pas fonctionner Ã  cause des restrictions)
        const r = await fetchWithTimeout(url, { 
          cache: "no-store",
          headers: {
            'Accept': 'application/json'
          }
        }, 2000);
        
        if (r.ok) {
          const data = await r.json();
          if (data.response && data.response.hits && data.response.hits.length > 0) {
            // Chercher un hit qui correspond
            for (const hit of data.response.hits) {
              if (hit.result) {
                const hitArtist = hit.result.primary_artist?.name || "";
                const hitTitle = hit.result.title || "";
                if (matchesResult({ artist: hitArtist, track: hitTitle }, artist, track)) {
                  if (hit.result.song_art_image_url) {
                    return hit.result.song_art_image_url;
                  }
                }
              }
            }
            // Prendre le premier rÃ©sultat avec image
            const firstHit = data.response.hits.find(h => h.result?.song_art_image_url);
            if (firstHit?.result?.song_art_image_url) {
              return firstHit.result.song_art_image_url;
            }
          }
        }
      } catch (err) {
        // Genius peut bloquer les requÃªtes sans clÃ©, c'est normal
        console.debug("Genius search (peut nÃ©cessiter une clÃ© API):", err);
      }
      return null;
    }

    // Recherche sur Bandcamp (scraping possible)
    async function searchBandcamp(artist, track) {
      try {
        if (!artist || !track) return null;
        
        // Bandcamp permet la recherche via leur site
        const query = `${artist} ${track}`;
        const searchUrl = `https://bandcamp.com/search?q=${encodeURIComponent(query)}`;
        
        // Le scraping direct ne fonctionne pas Ã  cause de CORS
        // On retourne null et on laisse les autres services prendre le relais
        return null;
      } catch (err) {
        console.warn("Bandcamp search error:", err);
      }
      return null;
    }

    async function ensureCover(explicitCover, track, artist) {
      // Normaliser les paramÃ¨tres
      const normTrack = track ? track.trim() : "";
      const normArtist = artist ? artist.trim() : "";
      const key = [explicitCover || "", normTrack, normArtist].join("|");
      
      // Si la clÃ© est la mÃªme ET que le cover actuel n'est pas le fallback, ne pas recharger
      // MAIS si lastCoverKey est vide (nouvelle piste dÃ©tectÃ©e), forcer la mise Ã  jour
      // MAIS aussi forcer la mise Ã  jour si on a un cover explicite diffÃ©rent
      const shouldSkip = key === lastCoverKey && 
                        lastCoverKey !== "" && 
                        coverEl.src && 
                        !coverEl.src.includes(FALLBACK_IMG) &&
                        !explicitCover; // Toujours mettre Ã  jour si on a un cover explicite
      
      if (shouldSkip) {
        console.log("Cover dÃ©jÃ  chargÃ© pour cette piste, skip");
        return;
      }
      
      // Mettre Ã  jour la clÃ© AVANT la recherche pour Ã©viter les recherches multiples simultanÃ©es
      lastCoverKey = key;

      // Si on a un cover explicite, l'utiliser directement
      if (explicitCover) {
        const bust = explicitCover.includes("?") ? "&" : "?";
        coverEl.src = explicitCover + bust + "t=" + Date.now();
        return;
      }

      // Si pas de track ni artist, utiliser le fallback
      if (!normTrack && !normArtist) {
        coverEl.src = FALLBACK_IMG;
        return;
      }

      console.log("Recherche de cover pour:", { artist: normArtist, track: normTrack });

      // Recherche en cascade sur TOUS les services en parallÃ¨le pour plus de rapiditÃ©
      // On essaie tous les services en mÃªme temps et on prend le premier rÃ©sultat
      const searchPromises = [
        searchITunes(normArtist, normTrack).catch(() => null),
        searchDeezer(normArtist, normTrack).catch(() => null),
        searchSpotify(normArtist, normTrack).catch(() => null),
        searchMusicBrainz(normArtist, normTrack).catch(() => null),
        searchLastFM(normArtist, normTrack).catch(() => null),
        searchDiscogs(normArtist, normTrack).catch(() => null),
        searchGenius(normArtist, normTrack).catch(() => null),
        searchAmazonMusic(normArtist, normTrack).catch(() => null),
        searchBandcamp(normArtist, normTrack).catch(() => null)
      ];

      // Attendre tous les rÃ©sultats et prendre le premier qui rÃ©ussit
      const results = await Promise.all(searchPromises);
      let coverUrl = results.find(url => url !== null && url !== undefined);

      // Si aucun rÃ©sultat, essayer une recherche plus large (sans artiste ou sans titre)
      if (!coverUrl && normTrack && normArtist) {
        console.log("Aucun rÃ©sultat trouvÃ©, essai avec recherche Ã©largie...");
        // Essayer avec seulement l'artiste ou seulement le titre
        const fallbackPromises = [
          searchITunes(normArtist, "").catch(() => null),
          searchDeezer(normArtist, "").catch(() => null),
          searchSpotify(normArtist, "").catch(() => null),
          searchITunes("", normTrack).catch(() => null),
          searchDeezer("", normTrack).catch(() => null),
          searchSpotify("", normTrack).catch(() => null)
        ];
        const fallbackResults = await Promise.all(fallbackPromises);
        coverUrl = fallbackResults.find(url => url !== null && url !== undefined);
      }

      // Mettre Ã  jour le cover
      if (coverUrl) {
        console.log("Cover trouvÃ©:", coverUrl);
        // Ajouter un timestamp pour Ã©viter le cache
        const finalUrl = coverUrl + (coverUrl.includes("?") ? "&" : "?") + "t=" + Date.now();
        coverEl.src = finalUrl;
        
        // VÃ©rifier que l'image se charge bien, sinon utiliser le fallback
        const img = new Image();
        img.onerror = () => {
          console.warn("Erreur chargement cover, utilisation du fallback");
          coverEl.src = FALLBACK_IMG;
        };
        img.src = finalUrl;
      } else {
        console.log("Aucun cover trouvÃ©, utilisation du fallback");
        coverEl.src = FALLBACK_IMG;
      }
    }

    async function updatePreviousTrackDisplay() {
      if (!previousTrackEl) return;
      
      if (previousTrackData && previousTrackData.track) {
        let coverUrl = previousTrackData.cover || FALLBACK_IMG;
        
        if (!previousTrackData.cover && previousTrackData.artist && previousTrackData.track) {
          // Utilise la mÃªme logique en cascade que ensureCover - tester tous les services
          const coverPromises = [
            searchITunes(previousTrackData.artist, previousTrackData.track),
            searchDeezer(previousTrackData.artist, previousTrackData.track),
            searchSpotify(previousTrackData.artist, previousTrackData.track),
            searchMusicBrainz(previousTrackData.artist, previousTrackData.track),
            searchLastFM(previousTrackData.artist, previousTrackData.track),
            searchDiscogs(previousTrackData.artist, previousTrackData.track),
            searchGenius(previousTrackData.artist, previousTrackData.track)
          ];
          const coverResults = await Promise.all(coverPromises.map(p => p.catch(() => null)));
          const foundCover = coverResults.find(url => url !== null && url !== undefined);
          if (foundCover) {
            coverUrl = foundCover;
          }
        }
        
        const artist = previousTrackData.artist || "";
        const track = previousTrackData.track || "";
        
        previousTrackEl.innerHTML = `
          <span class="label">PrÃ©cÃ©dent :</span>
          <table>
            <tr>
              <td class="prev-cover">
                <img src="${coverUrl}" alt="Cover prÃ©cÃ©dent" onerror="this.src='${FALLBACK_IMG}'">
              </td>
              <td class="prev-info">
                <div class="prev-artist">${artist || "Artiste inconnu"}</div>
                <div class="prev-title">${track}</div>
              </td>
            </tr>
          </table>
        `;
      } else {
        previousTrackEl.textContent = "";
      }
    }

    async function refreshPreviousTrack() {
      if (window.location.protocol === "file:") return;
      
      const historyFiles = [
        "Snip_History.json",
        "Snip_PlayHistory.json",
        "history.json",
        "playhistory.json",
        "Snip_Metadata.json"
      ];

      for (const file of historyFiles) {
        try {
          // Utiliser fetchWithTimeout pour Ã©viter les blocages
          const r = await fetchWithTimeout(file, { cache: "no-store" }, FETCH_TIMEOUT);
          if (!r.ok) continue;
          const data = await r.json();

          let history = null;
          
          if (Array.isArray(data)) {
            history = data;
          } else if (data.history && Array.isArray(data.history)) {
            history = data.history;
          } else if (data.previous) {
            history = [data.previous];
          } else if (data.last && data.last.track) {
            history = [data.last];
          } else if (data.previousTrack || data.previousTitle) {
            const prevTrack = normalizeText(data.previousTrack || data.previousTitle || "");
            const prevArtist = normalizeText(data.previousArtist || data.previousArtistName || "");
            if (prevTrack || prevArtist) {
              previousTrackData = { 
                track: prevTrack, 
                artist: prevArtist,
                cover: data.previousCover || data.previousAlbumArt || null
              };
              updatePreviousTrackDisplay();
              return;
            }
          } else if (data.tracks && Array.isArray(data.tracks)) {
            history = data.tracks;
          }

          if (history && history.length > 0) {
            const currentTrack = titleEl.textContent;
            const currentArtist = artistEl.textContent;
            
            // Au chargement initial, si on n'a pas encore de piste actuelle, prendre la derniÃ¨re de l'historique
            const isInitialState = !currentTrack || currentTrack === "Z Radio" || currentTrack === "Chargementâ€¦";
            
            let previous = null;
            
            // Parcourir l'historique de la fin vers le dÃ©but (les plus rÃ©centes en premier)
            for (let i = history.length - 1; i >= 0; i--) {
              const entry = history[i];
              const entryTrack = normalizeText(entry.track || entry.title || entry.name || "");
              const entryArtist = normalizeText(entry.artist || entry.artistName || entry.artist_name || "");
              
              if (entryTrack) {
                // Si c'est le chargement initial, prendre la derniÃ¨re entrÃ©e valide
                if (isInitialState) {
                  // Prendre la derniÃ¨re entrÃ©e qui a au moins un titre
                  if (entryTrack) {
                    previous = { 
                      track: entryTrack, 
                      artist: entryArtist || "",
                      cover: entry.cover || entry.albumArt || entry.artwork || null
                    };
                    break;
                  }
                } else {
                  // Sinon, chercher une piste diffÃ©rente de la piste actuelle
                  if (entryTrack !== currentTrack || entryArtist !== currentArtist) {
                    previous = { 
                      track: entryTrack, 
                      artist: entryArtist || "",
                      cover: entry.cover || entry.albumArt || entry.artwork || null
                    };
                    break;
                  }
                }
              }
            }

            if (previous) {
              previousTrackData = previous;
              updatePreviousTrackDisplay();
              return; // Sortir dÃ¨s qu'on a trouvÃ© une piste prÃ©cÃ©dente
            }
          }
        } catch (e) {
          // Erreur silencieuse pour les fichiers qui n'existent pas (normal)
          if (e.message && !e.message.includes("Timeout") && !e.message.includes("Failed to fetch")) {
            // Erreur silencieuse
          }
        }
      }
      
      updatePreviousTrackDisplay();
    }

    async function refreshSnip() {
      if (window.location.protocol === "file:") return;
      try {
        // Utiliser fetchWithTimeout pour Ã©viter les blocages
        const r = await fetchWithTimeout("Snip_Metadata.json", { cache: "no-store" }, FETCH_TIMEOUT);
        if (!r.ok) return; // Ã‰chec silencieux
        const meta = await r.json();

        const track  = meta.track  ? normalizeText(meta.track)  : "";
        const artist = meta.artist ? normalizeText(meta.artist) : "";
        const currentKey = track + "|" + artist;
        
        // Au chargement initial, toujours mettre Ã  jour mÃªme si on a dÃ©jÃ  un titre
        const shouldUpdate = isInitialLoad || currentKey !== lastTrackKey;

        // Au chargement initial, toujours rechercher le cover
        if (isInitialLoad && (track || artist)) {
          lastCoverKey = ""; // Forcer la recherche du cover au chargement initial
        }

        if (shouldUpdate && currentKey !== lastTrackKey && lastTrackKey) {
          const oldTrack = titleEl.textContent;
          const oldArtist = artistEl.textContent;
          const oldCover = coverEl.src;
          if (oldTrack && oldTrack !== "Chargementâ€¦") {
            previousTrackData = { 
              track: oldTrack, 
              artist: oldArtist,
              cover: oldCover !== FALLBACK_IMG ? oldCover : null
            };
            updatePreviousTrackDisplay();
          }
        }

        if (shouldUpdate && currentKey !== lastTrackKey) {
          // NOUVELLE PISTE : rÃ©initialiser le cover pour forcer la mise Ã  jour
          lastCoverKey = ""; // Forcer la recherche du cover
          lastTrackKey = currentKey;
          console.log("Nouvelle piste dÃ©tectÃ©e (Snip):", { track, artist });
          // Charger la pochette IMMÃ‰DIATEMENT pour la nouvelle piste
          ensureCover(meta.cover, track, artist).catch((err) => {
            console.warn("Erreur ensureCover:", err);
          });
          refreshPreviousTrack();
        } else if (shouldUpdate) {
          // MÃªme piste mais toujours vÃ©rifier le cover (au cas oÃ¹ il n'Ã©tait pas chargÃ©)
          // RÃ©initialiser lastCoverKey pour forcer la vÃ©rification
          if (!coverEl.src || coverEl.src.includes(FALLBACK_IMG)) {
            lastCoverKey = ""; // Forcer la recherche si on a le fallback
          }
          ensureCover(meta.cover, track, artist).catch((err) => {
            console.warn("Erreur ensureCover:", err);
          });
        }

        // Toujours mettre Ã  jour au chargement initial, sinon seulement si on a des donnÃ©es
        if (shouldUpdate || track || artist) {
          safeUpdateTitle(track);
          safeUpdateArtist(artist);
          // Si pas de nouvelle piste mais qu'on a des donnÃ©es, toujours vÃ©rifier le cover
          // (au cas oÃ¹ il n'Ã©tait pas chargÃ© ou si on a maintenant un cover explicite)
          if (currentKey === lastTrackKey && track && artist) {
            // Forcer la vÃ©rification si on a le fallback ou si on a un cover explicite
            if (!meta.cover || coverEl.src.includes(FALLBACK_IMG)) {
              lastCoverKey = ""; // Forcer la recherche
            }
            ensureCover(meta.cover, track, artist).catch((err) => {
              console.warn("Erreur ensureCover:", err);
            });
          }
        }
        lastSnipUpdate = Date.now();

      } catch (e) {
        // Erreur silencieuse, ne pas ralentir
      }
    }

    // Fonction de test de connectivitÃ© pour diagnostiquer les problÃ¨mes
    async function testConnectivity() {
      console.log("=== TEST DE CONNECTIVITÃ‰ ===");
      console.log("URLs Ã  tester:", STATUS_URLS);
      console.log("Flux audio:", ICECAST_BASE + "/stream");
      
      // Tester chaque URL
      for (const url of STATUS_URLS) {
        try {
          console.log("Test de:", url);
          const startTime = Date.now();
          const r = await fetchWithTimeout(url, { cache: "no-store", mode: "cors" }, 5000);
          const duration = Date.now() - startTime;
          
          if (r.ok) {
            console.log("âœ“ SuccÃ¨s:", url, `(${duration}ms)`);
            const data = await r.json();
            console.log("DonnÃ©es reÃ§ues:", data);
          } else {
            console.error("âœ— Erreur HTTP:", r.status, r.statusText, "pour", url);
          }
        } catch (e) {
          console.error("âœ— Ã‰chec:", url, "-", e.message || e);
        }
      }
      
      // Tester le flux audio
      try {
        console.log("Test du flux audio:", ICECAST_BASE + "/stream");
        const audioTest = await fetchWithTimeout(ICECAST_BASE + "/stream", { 
          method: "HEAD",
          cache: "no-store",
          mode: "cors"
        }, 5000);
        if (audioTest.ok) {
          console.log("âœ“ Flux audio accessible");
        } else {
          console.error("âœ— Flux audio - Erreur HTTP:", audioTest.status);
        }
      } catch (e) {
        console.error("âœ— Flux audio inaccessible:", e.message || e);
      }
      
      console.log("=== FIN DU TEST ===");
    }

    // Chargement ULTRA-RAPIDE : afficher la page immÃ©diatement, mÃ©tadonnÃ©es aprÃ¨s
    if (window.location.protocol !== "file:") {
      // Afficher un titre par dÃ©faut immÃ©diatement (dÃ©jÃ  fait dans le HTML)
      safeUpdateTitle("Z Radio");
      safeUpdateArtist("Live Stream");
      isInitialLoad = false;
      
      // Charger l'historique des pistes prÃ©cÃ©dentes IMMÃ‰DIATEMENT (avant les mÃ©tadonnÃ©es)
      // pour l'afficher dÃ¨s la premiÃ¨re visite
      refreshPreviousTrack().catch((err) => {
        console.warn("Ã‰chec refreshPreviousTrack initial:", err);
      });
      
      // Charger les mÃ©tadonnÃ©es EN ARRIÃˆRE-PLAN aprÃ¨s que la page soit affichÃ©e
      // Utiliser requestIdleCallback pour ne pas bloquer le rendu
      const loadMetadataAsync = () => {
        // Tester la connectivitÃ© d'abord pour diagnostiquer
        testConnectivity().then(() => {
          // Puis charger les mÃ©tadonnÃ©es ET l'historique des pistes prÃ©cÃ©dentes (mise Ã  jour)
          Promise.all([
            refreshIcecast().catch((err) => {
              console.error("Ã‰chec refreshIcecast:", err);
            }),
            refreshSnip().catch((err) => {
              console.error("Ã‰chec refreshSnip:", err);
            }),
            // Recharger l'historique aprÃ¨s avoir chargÃ© les mÃ©tadonnÃ©es pour s'assurer qu'on a la bonne piste prÃ©cÃ©dente
            refreshPreviousTrack().catch((err) => {
              console.error("Ã‰chec refreshPreviousTrack:", err);
            })
          ]).catch(() => {});
        });
      };
      
      // Attendre que le navigateur soit prÃªt, mais ne pas bloquer
      if ('requestIdleCallback' in window) {
        requestIdleCallback(loadMetadataAsync, { timeout: 200 });
      } else {
        // Fallback : dÃ©marrer aprÃ¨s 200ms (assez pour que la page s'affiche)
        setTimeout(loadMetadataAsync, 200);
      }

      // Clic sur le message de statut = rÃ©essayer la connexion (en cas de timeout / erreur)
      statusEl.addEventListener("click", () => {
        const t = (statusEl.textContent || "").toLowerCase();
        if (!t) return;
        if (t.includes("timeout") || t.includes("buffering") || t.includes("erreur") || t.includes("reconnexion") || t.includes("impossible") || t.includes("serveur")) {
          reconnectAttempts = 0;
          if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
          statusEl.textContent = "RÃ©essaiâ€¦";
          attemptReconnect(true);
        }
      });
      statusEl.title = "Cliquez pour rÃ©essayer en cas d'erreur";

      // Intervalles pour les mises Ã  jour pÃ©riodiques
      setInterval(refreshSnip, 2000);
      setInterval(refreshPreviousTrack, 3000);
      
      // GÃ©rer le rafraÃ®chissement de la page - rÃ©initialiser les compteurs
      window.addEventListener("beforeunload", () => {
        if (healthCheckTimer) {
          clearInterval(healthCheckTimer);
        }
        if (bufferingTimer) {
          clearTimeout(bufferingTimer);
        }
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
        }
      });
      
      // DÃ©tecter si la page revient au premier plan (aprÃ¨s un onglet inactif)
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden && !userPaused && player.paused) {
          // La page revient au premier plan et le player devrait jouer
          console.log("Page revenue au premier plan, vÃ©rification du flux...");
          setTimeout(() => {
            if (!userPaused && player.paused && player.readyState >= 2) {
              player.play().catch(err => {
                console.warn("Erreur lors de la reprise aprÃ¨s retour au premier plan:", err);
                if (!reconnectTimer) {
                  reconnectTimer = setTimeout(() => attemptReconnect(), 1000);
                }
              });
            } else if (player.readyState < 2) {
              // Le flux n'est pas prÃªt, reconnecter
              if (!reconnectTimer) {
                reconnectTimer = setTimeout(() => attemptReconnect(), 1000);
              }
            }
          }, 500);
        }
      });
    }

    function pickSource(icestats) {
      let s = icestats?.source;
      if (!s) return null;
      if (Array.isArray(s)) {
        return (
          s.find(o => (o.listenurl || "").endsWith(MOUNT)) ||
          s.find(o => (o.listeners || 0) > 0) ||
          s[0]
        );
      }
      return s;
    }

    async function refreshIcecast() {
      let lastError = null;
      let allErrors = [];
      
      for (const baseUrl of STATUS_URLS) {
        try {
          const url = baseUrl + (baseUrl.includes("?") ? "&" : "?") + "t=" + Date.now();
          console.log("Tentative de connexion Ã :", url);
          
          // Utiliser fetchWithTimeout pour Ã©viter les blocages
          const r = await fetchWithTimeout(url, { cache:"no-store", mode:"cors" }, FETCH_TIMEOUT);
          
          if (!r.ok) {
            const error = new Error(`HTTP ${r.status} - ${r.statusText}`);
            console.error("Erreur HTTP:", r.status, r.statusText, "pour", url);
            allErrors.push(error);
            throw error;
          }
          
          const data = await r.json();
          console.log("Connexion rÃ©ussie Ã :", baseUrl, "DonnÃ©es:", data);

          const src = pickSource(data.icestats);
          if (!src) throw new Error("Aucune source");

          const listenerCount = src.listeners ?? 0;
          const countSpan = document.getElementById("listenerCount");
          if (countSpan) countSpan.textContent = listenerCount;

          statusEl.textContent = "";
          statusFailCount = 0;

          const snipFresh = Date.now() - lastSnipUpdate < 7000;
          const hasTitle = titleEl.textContent && titleEl.textContent !== "Chargementâ€¦";
          const hasArtist = artistEl.textContent && artistEl.textContent.length > 0;
          
          // Au chargement initial, forcer la mise Ã  jour mÃªme si on a dÃ©jÃ  un titre
          const isInitialLoadState = isInitialLoad || (!hasTitle && !hasArtist);

          const iceTitle = src.title || src.server_name || "";
          if (iceTitle) {
            const [artistPart, ...titleParts] = iceTitle.split(" - ");
            const iceArtist = titleParts.length ? normalizeText(artistPart) : "";
            const iceTrack = titleParts.length ? normalizeText(titleParts.join(" - ")) : normalizeText(iceTitle);
            const iceKey = iceTrack + "|" + iceArtist;

            // Toujours mettre Ã  jour si c'est le chargement initial ou si on n'a pas de mÃ©tadonnÃ©es
            if (isInitialLoadState || !snipFresh || !hasTitle || !hasArtist || iceKey !== lastTrackKey) {
              if (iceKey !== lastTrackKey && lastTrackKey) {
                const oldTrack = titleEl.textContent;
                const oldArtist = artistEl.textContent;
                const oldCover = coverEl.src;
                if (oldTrack && oldTrack !== "Chargementâ€¦") {
                  previousTrackData = { 
                    track: oldTrack, 
                    artist: oldArtist,
                    cover: oldCover !== FALLBACK_IMG ? oldCover : null
                  };
                  updatePreviousTrackDisplay();
                }
              }

              // Au chargement initial, toujours mettre Ã  jour. Sinon, seulement si nÃ©cessaire
              if (isInitialLoadState) {
                // Chargement initial : forcer la mise Ã  jour
                if (iceArtist) safeUpdateArtist(iceArtist);
                if (iceTrack) safeUpdateTitle(iceTrack);
                // Au chargement initial, toujours rechercher le cover
                if (iceTrack || iceArtist) {
                  lastCoverKey = ""; // Forcer la recherche du cover
                  ensureCover(null, iceTrack, iceArtist).catch((err) => {
                    console.warn("Erreur ensureCover au chargement initial:", err);
                  });
                }
              } else {
                // Mise Ã  jour normale : seulement si nÃ©cessaire
                if ((!snipFresh || !hasArtist) && iceArtist) {
                  safeUpdateArtist(iceArtist);
                }
                if ((!snipFresh || !hasTitle) && iceTrack) {
                  safeUpdateTitle(iceTrack);
                }
              }
              
              if (iceKey !== lastTrackKey) {
                // NOUVELLE PISTE : rÃ©initialiser le cover pour forcer la mise Ã  jour
                lastCoverKey = "";
                lastTrackKey = iceKey;
                console.log("Nouvelle piste dÃ©tectÃ©e:", { track: iceTrack, artist: iceArtist });
                // Charger la pochette IMMÃ‰DIATEMENT pour la nouvelle piste
                ensureCover(null, iceTrack, iceArtist).catch((err) => {
                  console.warn("Erreur ensureCover pour nouvelle piste:", err);
                });
                refreshPreviousTrack();
              } else {
                // MÃªme piste mais toujours vÃ©rifier le cover (au cas oÃ¹ il n'Ã©tait pas chargÃ©)
                // Forcer la vÃ©rification si on a le fallback
                if (!coverEl.src || coverEl.src.includes(FALLBACK_IMG)) {
                  lastCoverKey = ""; // Forcer la recherche si on a le fallback
                }
                ensureCover(null, titleEl.textContent, artistEl.textContent).catch((err) => {
                  console.warn("Erreur ensureCover:", err);
                });
              }
              if (!snipFresh) lastSnipUpdate = 0;
            }
          }

          return; // SuccÃ¨s, on sort de la fonction
        } catch (e) {
          lastError = e;
          allErrors.push(e);
          console.warn("Ã‰chec de connexion Ã ", baseUrl, ":", e.message || e);
        }
      }

      // Si on arrive ici, toutes les tentatives ont Ã©chouÃ©
      if (lastError) {
        console.error("Toutes les tentatives de connexion ont Ã©chouÃ©:", allErrors);
        
        // Diagnostic dÃ©taillÃ©
        const errorDetails = allErrors.map(e => {
          if (e.message) {
            if (e.message.includes("Failed to fetch") || e.message.includes("NetworkError")) {
              return "Erreur rÃ©seau - Le serveur est peut-Ãªtre inaccessible";
            }
            if (e.message.includes("HTTP 404")) {
              return "Page non trouvÃ©e (404) - VÃ©rifiez l'URL";
            }
            if (e.message.includes("HTTP 503")) {
              return "Service indisponible (503) - Le serveur Icecast est peut-Ãªtre arrÃªtÃ©";
            }
            if (e.message.includes("HTTP 500")) {
              return "Erreur serveur (500) - ProblÃ¨me cÃ´tÃ© serveur";
            }
            if (e.message.includes("Timeout")) {
              return "Timeout - Le serveur ne rÃ©pond pas assez vite";
            }
            if (e.message.includes("CORS")) {
              return "Erreur CORS - ProblÃ¨me de configuration Caddy";
            }
            return e.message;
          }
          return String(e);
        }).join(" | ");
        
        console.error("DÃ©tails des erreurs:", errorDetails);
      }
      
      statusFailCount++;
      const playerLooksOk = !player.paused && player.readyState >= 2;
      
      if (!playerLooksOk && statusFailCount >= STATUS_FAIL_THRESHOLD) {
        // PrÃ©server le titre actuel au lieu de le rÃ©initialiser
        if (!lastKnownTitle && titleEl.textContent && titleEl.textContent !== "Chargementâ€¦") {
          lastKnownTitle = titleEl.textContent;
        }
        if (!lastKnownArtist && artistEl.textContent) {
          lastKnownArtist = artistEl.textContent;
        }
        
        // Afficher un message d'erreur plus dÃ©taillÃ©
        if (player.readyState < 2 || statusFailCount >= STATUS_FAIL_THRESHOLD) {
          let errorMsg = "Connexion au serveurâ€¦";
          if (lastError) {
            const errorMsg_lower = lastError.message ? lastError.message.toLowerCase() : "";
            if (errorMsg_lower.includes("failed to fetch") || errorMsg_lower.includes("networkerror")) {
              errorMsg = "Serveur inaccessible - VÃ©rifiez que Caddy et Icecast fonctionnent";
            } else if (errorMsg_lower.includes("http 503") || errorMsg_lower.includes("503")) {
              errorMsg = "Service indisponible (503) - Icecast est peut-Ãªtre arrÃªtÃ©";
            } else if (errorMsg_lower.includes("http 404") || errorMsg_lower.includes("404")) {
              errorMsg = "Page non trouvÃ©e (404) - VÃ©rifiez la configuration Caddy";
            } else if (errorMsg_lower.includes("http 500") || errorMsg_lower.includes("500")) {
              errorMsg = "Erreur serveur (500) - ProblÃ¨me cÃ´tÃ© serveur";
            } else if (errorMsg_lower.includes("timeout") || errorMsg_lower.includes("aborted")) {
              errorMsg = "Timeout - Le serveur ne rÃ©pond pas assez vite";
            } else if (errorMsg_lower.includes("cors")) {
              errorMsg = "Erreur CORS - ProblÃ¨me de configuration";
            } else {
              errorMsg = `Impossible de se connecter: ${lastError.message || "Erreur inconnue"}`;
            }
          }
          statusEl.textContent = errorMsg;
          console.error("Message d'erreur affichÃ©:", errorMsg);
        }
        coverEl.src = FALLBACK_IMG;
      }
    }

    // refreshIcecast() est maintenant appelÃ© dans loadMetadata() pour Ã©viter le double appel
    // Mais on garde l'intervalle pour les mises Ã  jour pÃ©riodiques
    setInterval(refreshIcecast, 15000);

    // Fonction de reconnexion automatique amÃ©liorÃ©e
    function attemptReconnect(forceReset = false) {
      if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        // RÃ©initialiser le compteur aprÃ¨s un certain temps pour permettre de nouvelles tentatives
        if (forceReset) {
          reconnectAttempts = 0;
          console.log("RÃ©initialisation du compteur de reconnexion");
        } else {
          statusEl.textContent = "Reconnexion dans 10 sâ€¦ (ou cliquez sur Play)";
          // AprÃ¨s 10 secondes, rÃ©initialiser et rÃ©essayer (reconnexion persistante)
          setTimeout(() => {
            reconnectAttempts = 0;
            attemptReconnect(true);
          }, 10000);
          return;
        }
      }

      // Nettoyer tous les timers
      if (bufferingTimer) {
        clearTimeout(bufferingTimer);
        bufferingTimer = null;
      }
      if (healthCheckTimer) {
        clearInterval(healthCheckTimer);
        healthCheckTimer = null;
      }

      reconnectAttempts++;
      statusEl.textContent = `Reconnexionâ€¦ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`;
      
      // PrÃ©server le titre actuel
      if (lastKnownTitle && titleEl.textContent === "Chargementâ€¦") {
        titleEl.textContent = lastKnownTitle;
      }
      if (lastKnownArtist && !artistEl.textContent) {
        artistEl.textContent = lastKnownArtist;
      }

      // RÃ©initialiser COMPLÃˆTEMENT le lecteur
      try {
        // ArrÃªter complÃ¨tement le player
        player.pause();
        player.src = "";
        player.load();
        
        // Attendre un peu pour que le navigateur libÃ¨re les ressources
        setTimeout(() => {
          // RÃ©assigner toutes les sources avec un cache-busting
          const cacheBuster = "?t=" + Date.now() + "&r=" + Math.random();
          const sources = player.querySelectorAll("source");
          sources.forEach(source => {
            source.src = STREAM_URL + cacheBuster;
          });
          
          // RÃ©assigner aussi player.src directement
          player.src = STREAM_URL + cacheBuster;
          player.load();
          
          // Attendre que le player soit prÃªt avant de jouer
          const tryPlay = () => {
            if (player.readyState >= 2) {
              // Le flux est prÃªt, essayer de jouer
              player.play().then(() => {
                console.log("Reconnexion rÃ©ussie !");
                reconnectAttempts = 0; // RÃ©initialiser le compteur en cas de succÃ¨s
                lastPlayTime = Date.now();
                startHealthCheck(); // RedÃ©marrer le health check
              }).catch(err => {
                console.warn("Tentative de reconnexion Ã©chouÃ©e:", err);
                if (!reconnectTimer) {
                  reconnectTimer = setTimeout(() => attemptReconnect(), RECONNECT_DELAY);
                }
              });
            } else {
              // Attendre un peu plus
              setTimeout(tryPlay, 100);
            }
          };
          
          // Essayer de jouer aprÃ¨s un court dÃ©lai
          setTimeout(tryPlay, 200);
        }, 200);
      } catch (e) {
        console.error("Erreur lors de la reconnexion:", e);
        if (!reconnectTimer) {
          reconnectTimer = setTimeout(() => attemptReconnect(), RECONNECT_DELAY);
        }
      }
    }

    // SystÃ¨me de health check pour dÃ©tecter les blocages
    let lastHealthCheckTime = 0;
    let lastHealthCheckCurrentTime = 0;
    
    function startHealthCheck() {
      if (healthCheckTimer) {
        clearInterval(healthCheckTimer);
      }
      
      lastHealthCheckTime = Date.now();
      lastHealthCheckCurrentTime = player.currentTime;
      
      healthCheckTimer = setInterval(() => {
        if (userPaused) return; // Ne pas vÃ©rifier si l'utilisateur a mis en pause
        
        const now = Date.now();
        const timeSinceLastPlay = now - lastPlayTime;
        const timeSinceLastCheck = now - lastHealthCheckTime;
        const currentTime = player.currentTime;
        
        // VÃ©rifier si le player est bloquÃ©
        if (!player.paused) {
          // Si le player est censÃ© jouer mais est en "waiting" ou "stalled" depuis trop longtemps
          if (player.readyState < 2 && timeSinceLastPlay > MAX_STALL_TIME) {
            console.warn("Flux bloquÃ© dÃ©tectÃ© (readyState < 2), reconnexion...");
            if (!reconnectTimer) {
              reconnectTimer = setTimeout(() => attemptReconnect(), 1000);
            }
            return;
          }
          
          // Si le player n'a pas progressÃ© depuis trop longtemps (timeout de progression)
          if (timeSinceLastCheck > MAX_STALL_TIME) {
            const timeProgressed = currentTime - lastHealthCheckCurrentTime;
            // Si le temps n'a pas progressÃ© (ou trÃ¨s peu) alors que le player devrait jouer
            if (timeProgressed < 0.5 && timeSinceLastPlay > MAX_STALL_TIME) {
              console.warn("Flux ne progresse pas (timeout de progression), reconnexion...");
              if (!reconnectTimer) {
                reconnectTimer = setTimeout(() => attemptReconnect(), 1000);
              }
              return;
            }
          }
          
          // Mettre Ã  jour les valeurs pour le prochain check
          lastHealthCheckTime = now;
          lastHealthCheckCurrentTime = currentTime;
        }
      }, HEALTH_CHECK_INTERVAL);
    }

    // ---- Gestion du bouton Play/Pause avec reconnexion automatique
    player.addEventListener("play", () => {
      // Nettoyer le timer de buffering
      if (bufferingTimer) {
        clearTimeout(bufferingTimer);
        bufferingTimer = null;
      }
      
      // DÃ©marrer le health check quand on joue
      startHealthCheck();
      lastPlayTime = Date.now();
      
      // Si l'utilisateur a mis en pause puis relance, actualiser le flux
      const shouldRefresh = wasPaused && userPaused;
      
      if (shouldRefresh) {
        console.debug("Reprise aprÃ¨s pause : actualisation du flux");
        statusEl.textContent = "Actualisation du fluxâ€¦";
        
        // Recharger le flux pour obtenir la version la plus rÃ©cente
        try {
          // RÃ©initialiser la source pour forcer une nouvelle connexion
          player.src = "";
          player.load();
          
          // RÃ©assigner avec l'URL correcte
          const sources = player.querySelectorAll("source");
          sources.forEach(source => {
            source.src = STREAM_URL + "?t=" + Date.now();
          });
          player.src = STREAM_URL + "?t=" + Date.now();
          player.load();
          
          // Attendre que le flux soit prÃªt avant de jouer
          const waitAndPlay = () => {
            if (player.readyState >= 2) {
              // Le flux est prÃªt, dÃ©marrer la lecture
              player.play().catch(err => {
                console.warn("Erreur lors de la reprise:", err);
                statusEl.textContent = "";
              });
            } else {
              // Attendre un peu plus
              setTimeout(waitAndPlay, 100);
            }
          };
          
          // Essayer de jouer immÃ©diatement, sinon attendre
          setTimeout(() => {
            player.play().catch(() => {
              setTimeout(waitAndPlay, 200);
            });
          }, 50);
        } catch (e) {
          console.error("Erreur lors de l'actualisation du flux:", e);
          statusEl.textContent = "";
        }
      }
      
      userPaused = false;
      wasPaused = false; // RÃ©initialiser le flag
      reconnectAttempts = 0; // RÃ©initialiser le compteur en cas de succÃ¨s
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      if (!shouldRefresh) {
        statusEl.textContent = ""; // Effacer le message seulement si pas d'actualisation
      }
      const audioBars = document.getElementById("audioBars");
      if (audioBars) audioBars.classList.remove("hidden");
    });

    player.addEventListener("pause", () => {
      userPaused = true;
      wasPaused = true; // Marquer qu'on vient de mettre en pause
      if (bufferingTimer) {
        clearTimeout(bufferingTimer);
        bufferingTimer = null;
      }
      if (healthCheckTimer) {
        clearInterval(healthCheckTimer);
        healthCheckTimer = null;
      }
      const audioBars = document.getElementById("audioBars");
      if (audioBars) audioBars.classList.add("hidden");
    });

    player.addEventListener("playing", () => {
      reconnectAttempts = 0; // RÃ©initialiser le compteur quand la lecture reprend
      lastPlayTime = Date.now(); // Mettre Ã  jour le temps de derniÃ¨re lecture
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      if (bufferingTimer) {
        clearTimeout(bufferingTimer);
        bufferingTimer = null;
      }
      statusEl.textContent = ""; // Effacer le message de reconnexion
      const audioBars = document.getElementById("audioBars");
      if (audioBars) audioBars.classList.remove("hidden");
      startHealthCheck(); // RedÃ©marrer le health check
    });

    // DÃ©tecter les interruptions de lecture
    player.addEventListener("stalled", () => {
      if (!userPaused) {
        console.warn("Flux en pause (stalled), tentative de reconnexion...");
        if (bufferingTimer) {
          clearTimeout(bufferingTimer);
          bufferingTimer = null;
        }
        // Attendre un peu avant de reconnecter (peut Ãªtre temporaire)
        setTimeout(() => {
          if (!userPaused && player.readyState < 2 && !reconnectTimer) {
            reconnectTimer = setTimeout(() => attemptReconnect(), RECONNECT_DELAY);
          }
        }, 3000);
      }
    });

    player.addEventListener("waiting", () => {
      if (!userPaused) {
        statusEl.textContent = "Bufferingâ€¦";
        
        // Si le buffering prend trop de temps, forcer une reconnexion
        if (bufferingTimer) {
          clearTimeout(bufferingTimer);
        }
        
        bufferingTimer = setTimeout(() => {
          if (!userPaused && player.readyState < 2) {
            // Le flux n'a pas assez de donnÃ©es aprÃ¨s 4 secondes
            console.warn("Buffering trop long, tentative de reconnexion...");
            statusEl.textContent = "Reconnexionâ€¦";
            bufferingTimer = null;
            
            // Forcer une reconnexion avec l'URL correcte
            try {
              player.src = "";
              player.load();
              setTimeout(() => {
                // Utiliser l'URL du stream directement
                const sources = player.querySelectorAll("source");
                sources.forEach(source => {
                  source.src = STREAM_URL + "?t=" + Date.now();
                });
                player.src = STREAM_URL + "?t=" + Date.now();
                player.load();
                player.play().catch(err => {
                  console.warn("Erreur aprÃ¨s reconnexion buffering:", err);
                  if (!reconnectTimer) {
                    reconnectTimer = setTimeout(attemptReconnect, RECONNECT_DELAY);
                  }
                });
              }, 100);
            } catch (e) {
              console.error("Erreur lors de la reconnexion buffering:", e);
              if (!reconnectTimer) {
                reconnectTimer = setTimeout(attemptReconnect, RECONNECT_DELAY);
              }
            }
          }
        }, BUFFERING_TIMEOUT);
      }
    });

    // DÃ©marrer la lecture dÃ¨s que possible (mÃªme si pas complÃ¨tement chargÃ©)
    player.addEventListener("canplay", () => {
      if (!userPaused && player.paused && statusEl.textContent === "Bufferingâ€¦") {
        // Le flux a assez de donnÃ©es pour dÃ©marrer, essayer de jouer
        player.play().then(() => {
          lastPlayTime = Date.now();
          startHealthCheck();
        }).catch(err => {
          console.debug("Tentative de lecture automatique (canplay):", err);
        });
      }
      
      // Nettoyer le timer de buffering si le flux peut Ãªtre lu
      if (bufferingTimer) {
        clearTimeout(bufferingTimer);
        bufferingTimer = null;
      }
    });

    player.addEventListener("canplaythrough", () => {
      // Le flux peut Ãªtre lu sans interruption
      if (statusEl.textContent === "Actualisation du fluxâ€¦" || statusEl.textContent === "Bufferingâ€¦") {
        statusEl.textContent = "";
      }
      
      // Nettoyer le timer de buffering
      if (bufferingTimer) {
        clearTimeout(bufferingTimer);
        bufferingTimer = null;
      }
    });
    
    // Gestion des erreurs du lecteur avec reconnexion automatique
    player.addEventListener("error", (e) => {
      const error = player.error;
      let errorMsg = "Erreur de lecture";
      let shouldReconnect = false;
      
      if (error) {
        switch (error.code) {
          case error.MEDIA_ERR_ABORTED:
            errorMsg = "Lecture interrompue";
            // Ne pas reconnecter pour les interruptions manuelles
            break;
          case error.MEDIA_ERR_NETWORK:
            errorMsg = "Erreur rÃ©seau - Impossible de se connecter au flux audio";
            shouldReconnect = true;
            console.error("Erreur rÃ©seau audio - VÃ©rifiez que le flux est accessible Ã :", STREAM_URL);
            // Si c'est un timeout rÃ©seau, attendre un peu plus avant de reconnecter
            if (player.networkState === 3) { // NETWORK_NO_SOURCE
              console.warn("Timeout rÃ©seau dÃ©tectÃ© - le serveur ne rÃ©pond pas");
              errorMsg = "Timeout - Le serveur ne rÃ©pond pas. VÃ©rifiez que Caddy et Icecast fonctionnent.";
            }
            break;
          case error.MEDIA_ERR_DECODE:
            errorMsg = "Erreur de dÃ©codage - Nouvelle tentativeâ€¦";
            shouldReconnect = true;
            break;
          case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
            // VÃ©rifier si c'est vraiment un problÃ¨me de format ou un problÃ¨me de connexion
            if (player.networkState === 3) { // NETWORK_NO_SOURCE
              // C'est probablement un timeout rÃ©seau, pas un problÃ¨me de format
              errorMsg = "Timeout - Le serveur ne rÃ©pond pas. VÃ©rifiez que Caddy et Icecast fonctionnent.";
              shouldReconnect = true;
              console.error("Timeout rÃ©seau dÃ©tectÃ© - le serveur ne rÃ©pond pas Ã :", STREAM_URL);
            } else {
              errorMsg = "Format non supportÃ© - VÃ©rification du type MIME...";
              shouldReconnect = true; // Essayer de reconnecter avec dÃ©tection automatique
              // Tester le Content-Type rÃ©el du flux
              testStreamContentType().then(contentType => {
                console.log("Content-Type dÃ©tectÃ©:", contentType);
                if (contentType) {
                  errorMsg = `Format dÃ©tectÃ©: ${contentType} - Reconnexion...`;
                  statusEl.textContent = errorMsg;
                  // Essayer de recharger avec le bon type
                  setTimeout(() => {
                    if (!userPaused && !reconnectTimer) {
                      reconnectTimer = setTimeout(attemptReconnect, 500);
                    }
                  }, 1000);
                } else {
                  errorMsg = "Format non supportÃ© - VÃ©rifiez la configuration Icecast";
                  statusEl.textContent = errorMsg;
                }
              }).catch(err => {
                console.error("Erreur lors de la dÃ©tection du Content-Type:", err);
                // Si la dÃ©tection Ã©choue, c'est probablement un timeout rÃ©seau
                if (err.message && err.message.includes("Timeout")) {
                  errorMsg = "Timeout - Le serveur ne rÃ©pond pas. VÃ©rifiez que Caddy et Icecast fonctionnent.";
                } else {
                  errorMsg = "Format non supportÃ© - Impossible de dÃ©tecter le type";
                }
                statusEl.textContent = errorMsg;
              });
            }
            break;
          default:
            errorMsg = `Erreur (${error.code}) - Nouvelle tentativeâ€¦`;
            shouldReconnect = true;
        }
        
        console.error("Erreur lecteur audio:", {
          code: error.code,
          message: errorMsg,
          networkState: player.networkState,
          readyState: player.readyState,
          src: player.src,
          expectedSrc: STREAM_URL
        });
      } else {
        console.error("Erreur lecteur (sans dÃ©tails):", e);
        shouldReconnect = true;
      }
      
      // PrÃ©server le titre actuel
      if (!lastKnownTitle && titleEl.textContent && titleEl.textContent !== "Chargementâ€¦") {
        lastKnownTitle = titleEl.textContent;
      }
      if (!lastKnownArtist && artistEl.textContent) {
        lastKnownArtist = artistEl.textContent;
      }
      
      // EmpÃªcher que "Chargementâ€¦" rÃ©apparaisse
      if (titleEl.textContent === "Chargementâ€¦" && lastKnownTitle) {
        titleEl.textContent = lastKnownTitle;
      }
      if (!artistEl.textContent && lastKnownArtist) {
        artistEl.textContent = lastKnownArtist;
      }
      
      statusEl.textContent = errorMsg;
      
      // Nettoyer le timer de buffering en cas d'erreur
      if (bufferingTimer) {
        clearTimeout(bufferingTimer);
        bufferingTimer = null;
      }
      
      // Tentative de reconnexion automatique pour les erreurs rÃ©seau
      if (shouldReconnect && !userPaused && !reconnectTimer) {
        reconnectTimer = setTimeout(attemptReconnect, RECONNECT_DELAY);
      }
    });
  </script>
</body>
</html>
