<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Z Radio â€“ Live Stream</title>
  <style>
    :root { --accent:#1db954; --bg1:#0e0e0e; --bg2:#232526; }
    *{ box-sizing:border-box; margin:0; padding:0; }
    body{
      min-height:100vh; display:flex; justify-content:center; align-items:center; flex-direction:column;
      font-family:system-ui, sans-serif; background:linear-gradient(145deg,var(--bg1),var(--bg2));
      color:#f5f5f5; text-align:center; padding:1.2rem;
    }
    h1{ font-size:2.6rem; color:var(--accent); margin-bottom:.2em; }
    small{ color:#aaa; }
    #coverWrapper{
      width:220px; height:220px; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,.4);
      margin:1.3em 0 .8em; overflow:hidden;
    }
    img#cover{ width:100%; height:100%; object-fit:cover; display:block; }
    audio{ width:220px; height:40px; margin-bottom:1em; filter:drop-shadow(0 2px 4px rgba(0,0,0,.5)); }
    .meta{ font-size:1.05rem; margin-top:.3em; }
    #listeners{ font-size:.9rem; color:#ccc; margin-top:.2em; }
    footer{ margin-top:2.5rem; font-size:.8rem; color:#888; }
    a{ color:var(--accent); }
    .song-title{ font-weight:bold; font-size:1rem; }
    .artist-name{ margin-top:.2em; color:#aaa; font-size:1rem; }
    #status{ margin-top:.6rem; font-size:.9rem; color:#ffd166; min-height:1.1em; }
  </style>
</head>
<body>

  <h1>ðŸŽµ Z Radio</h1>
  <small>Musique 24 / 7 â€“ Hits & Classics</small>

  <div id="coverWrapper">
    <img id="cover" src="cover.gif" alt="Pochette de l'album">
  </div>

  <audio id="player" controls preload="auto">
    <source id="src" src="https://z-radio.viewdns.net/stream" type="audio/mpeg">
    Votre navigateur ne supporte pas l'audio HTML5.
  </audio>

  <div id="title" class="meta song-title">Chargementâ€¦</div>
  <div id="artist" class="artist-name"></div>
  <div id="listeners">Auditeurs : --</div>
  <div id="status"></div>

  <footer>
    Â© 2025 <span style="color:var(--accent)">Z Radio</span> â€“ Created by <span style="color:var(--accent)">Zakaria ELORCHE</span><br/>
    Powered by <a href="#" target="_blank" rel="noopener">Icecast 2</a>
  </footer>

  <script>
    // ---- CONFIG
    const ICECAST_BASE = "https://z-radio.viewdns.net";
    const STATUS_URLS  = [
      ICECAST_BASE + "/status-json.xsl?mount=/stream",
      ICECAST_BASE + "/status-json.xsl"
    ];
    const MOUNT        = "/stream";
    const FALLBACK_IMG = "cover.gif";

    // ---- DOM ELEMENTS
    const player   = document.getElementById("player");
    const srcEl    = document.getElementById("src");
    const coverEl  = document.getElementById("cover");
    const titleEl  = document.getElementById("title");
    const artistEl = document.getElementById("artist");
    const listEl   = document.getElementById("listeners");
    const statusEl = document.getElementById("status");

    let lastCoverKey = "";
    let lastSnipUpdate = 0;

    function normalizeText(str) {
      if (!str) return "";
      return str.replace(/^["'\s]+|["'\s]+$/g, "");
    }

    async function ensureCover(explicitCover, track, artist) {
      const key = [explicitCover || "", track || "", artist || ""].join("|");
      if (key === lastCoverKey) return;
      lastCoverKey = key;

      if (explicitCover) {
        // Ã©vite le cache quand Snip rÃ©Ã©crit la mÃªme URL
        const bust = explicitCover.includes("?") ? "&" : "?";
        coverEl.src = explicitCover + bust + "t=" + Date.now();
        return;
      }

      const query = [artist, track].filter(Boolean).join(" ");
      if (!query) {
        coverEl.src = FALLBACK_IMG;
        return;
      }

      try {
        const url =
          "https://itunes.apple.com/search?entity=song&limit=1&term=" +
          encodeURIComponent(query);
        const r = await fetch(url, { cache: "no-store" });
        const data = await r.json();
        const art =
          data.results &&
          data.results[0] &&
          data.results[0].artworkUrl100;
        if (art) {
          coverEl.src = art.replace("100x100", "300x300");
          return;
        }
      } catch (err) {
        console.warn("Cover fetch error:", err);
      }

      // DeuxiÃ¨me fournisseur : MusicBrainz + Cover Art Archive
      try {
        const mbQuery =
          "https://musicbrainz.org/ws/2/recording/?fmt=json&limit=1&query=" +
          encodeURIComponent(`recording:"${track}" AND artist:"${artist}"`);
        const mr = await fetch(mbQuery, { cache: "no-store" });
        const md = await mr.json();
        const releaseId =
          md.recordings &&
          md.recordings[0] &&
          md.recordings[0].releases &&
          md.recordings[0].releases[0] &&
          md.recordings[0].releases[0].id;
        if (releaseId) {
          // CAA expose CORS, on peut demander l'image directe
          const caa = "https://coverartarchive.org/release/" + releaseId + "/front-500";
          // On teste qu'elle existe
          const imgResp = await fetch(caa, { method: "HEAD" });
          if (imgResp.ok) {
            coverEl.src = caa + "?t=" + Date.now();
            return;
          }
        }
      } catch (err2) {
        console.warn("Cover MB/CoverArt error:", err2);
      }

      coverEl.src = FALLBACK_IMG;
    }

    // --------------------------------------
    // ðŸ”µ Snip : Lecture du vrai titre / artiste
    // --------------------------------------
    async function refreshSnip() {
      try {
        const r = await fetch("Snip_Metadata.json", { cache: "no-store" });
        const meta = await r.json();

        const track  = meta.track  ? normalizeText(meta.track)  : "";
        const artist = meta.artist ? normalizeText(meta.artist) : "";

        if (track)  titleEl.textContent  = track;
        if (artist) artistEl.textContent = artist;

        await ensureCover(meta.cover, track, artist);
        lastSnipUpdate = Date.now();

      } catch (e) {
        console.warn("Snip error:", e);
      }
    }

    refreshSnip();
    setInterval(refreshSnip, 2000);

    // --------------------------------------
    // ðŸŸ¢ Icecast : Auditeurs + fallback titre
    // --------------------------------------
    function pickSource(icestats) {
      let s = icestats?.source;
      if (!s) return null;
      if (Array.isArray(s)) {
        return (
          s.find(o => (o.listenurl || "").endsWith(MOUNT)) ||
          s.find(o => (o.listeners || 0) > 0) ||
          s[0]
        );
      }
      return s;
    }

    async function refreshIcecast() {
      let lastError = null;
      for (const url of STATUS_URLS) {
        try {
          const r = await fetch(url, { cache:"no-store", mode:"cors" });
          if (!r.ok) throw new Error("HTTP " + r.status);
          const data = await r.json();

          const src = pickSource(data.icestats);
          if (!src) throw new Error("Aucune source");

          listEl.textContent = "Auditeurs : " + (src.listeners ?? 0);
          statusEl.textContent = "";

          const snipFresh = Date.now() - lastSnipUpdate < 7000;
          const hasTitle = titleEl.textContent && titleEl.textContent !== "Chargementâ€¦";
          const hasArtist = artistEl.textContent && artistEl.textContent.length > 0;

          // fallback titre/artiste depuis Icecast si Snip inactif ou donnÃ©es manquantes
          if (!snipFresh || !hasTitle || !hasArtist) {
            const iceTitle = src.title || src.server_name || "";
            if (iceTitle) {
              const [artistPart, ...titleParts] = iceTitle.split(" - ");
              let fallbackArtist = artistEl.textContent;
              let fallbackTitleText = titleEl.textContent;

              if ((!snipFresh || !hasArtist) && titleParts.length) {
                fallbackArtist = normalizeText(artistPart);
                artistEl.textContent = fallbackArtist;
              }
              if (!snipFresh || !hasTitle) {
                const fallbackTitle = titleParts.length ? titleParts.join(" - ") : iceTitle;
                fallbackTitleText = normalizeText(fallbackTitle);
                titleEl.textContent = fallbackTitleText;
              }

              await ensureCover(null, fallbackTitleText, fallbackArtist);
              if (!snipFresh) {
                lastSnipUpdate = 0;
              }
            }
          }

          return;
        } catch (e) {
          lastError = e;
        }
      }

      console.error(lastError);
      statusEl.textContent = "Flux indisponibleâ€¦";
      coverEl.src = FALLBACK_IMG;
    }

    refreshIcecast();
    setInterval(refreshIcecast, 15000);

    // --------------------------------------
    // ðŸ” Reconnexion auto en cas dâ€™erreur lecteur
    // --------------------------------------
    srcEl.src = ICECAST_BASE + MOUNT;

    let userPaused = false;
    let reconnectTimer = null;
    let retryDelayMs = 1500;

    function scheduleReconnect() {
      if (reconnectTimer) return;
      reconnectTimer = setTimeout(async () => {
        reconnectTimer = null;
        try {
          srcEl.src = ICECAST_BASE + MOUNT + "?t=" + Date.now();
          player.load();
          if (!userPaused) {
            await player.play().catch(() => {});
          }
        } finally {
          // backoff progressif jusqu'Ã  10s max
          retryDelayMs = Math.min(retryDelayMs * 1.7, 10000);
        }
      }, retryDelayMs);
    }

    function onStreamProblem() {
      if (document.visibilityState === "hidden") return; // Ã©vite spam quand onglet inactif
      scheduleReconnect();
    }

    player.addEventListener("play", () => {
      userPaused = false;
      retryDelayMs = 1500;
    });
    player.addEventListener("pause", () => {
      // Si c'est l'utilisateur qui a cliquÃ© pause, on ne force pas la reprise
      userPaused = true;
    });

    // ProblÃ¨mes rÃ©seau frÃ©quents
    ["error", "stalled", "suspend", "waiting", "emptied", "abort"].forEach(evt => {
      player.addEventListener(evt, onStreamProblem);
    });

    // Quand le flux redevient lisible
    player.addEventListener("canplay", async () => {
      if (!userPaused) {
        await player.play().catch(() => {});
      }
    });

    // Re-tente quand on revient sur lâ€™onglet
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible" && player.paused && !userPaused) {
        retryDelayMs = 1500;
        scheduleReconnect();
      }
    });
  </script>
</body>
</html>
